"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[7212],{6262:(i,s)=>{s.A=(i,s)=>{const a=i.__vccOpts||i;for(const[i,n]of s)a[i]=n;return a}},4507:(i,s,a)=>{a.r(s),a.d(s,{comp:()=>h,data:()=>p});var n=a(641);const l=a.p+"assets/img/3.cc3ebb91.png",e=a.p+"assets/img/4.4933671b.jpg",t={},h=(0,a(6262).A)(t,[["render",function(i,s){return(0,n.uX)(),(0,n.CE)("div",null,s[0]||(s[0]=[(0,n.Fv)('<h1 id="_2-9-3-锁优化" tabindex="-1"><a class="header-anchor" href="#_2-9-3-锁优化"><span>2.9.3 锁优化</span></a></h1><p>有哪些锁优化技术？</p><ul><li>自适应自旋</li><li>锁消除</li><li>锁膨胀</li><li>轻量级锁</li></ul><h2 id="一、自旋锁与自适应锁" tabindex="-1"><a class="header-anchor" href="#一、自旋锁与自适应锁"><span>一、自旋锁与自适应锁</span></a></h2><p>互斥同步对性能最大的影响是阻塞的实现，挂起和恢复线程操作都需要转入内核态中完成。</p><p><strong>自旋锁</strong>：如果有多个处理器核心，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一会儿”，但不放弃处理器的执行时间，看看持有锁的线程释放很快就会释放锁。为了让线程等待，我们只须让线程执行一个忙循环（自旋）。</p><p>自旋不能代替阻塞，先不说对处理器的要求，自旋等待本身虽然避免了线程切换的开销，但它要占用处理器的时间。如果锁占用的时间很短，自旋等待的效果就会非常好，反之，带来性能浪费。因此自旋等待时间必须有一定的限度，自旋次数的默认值是10次，用户也可以使用JVM参数自行更改。</p><p>无论用户指定自旋次数还是用默认自旋次数，自旋时间都是固定的。在JDK6中对自旋锁进行优化，引入了自适应的自旋。</p><p>自适应自旋的时间不再固定，而是由前一次在同一个锁上自旋时间以及锁拥有者的状态来决定</p><h2 id="二、锁消除" tabindex="-1"><a class="header-anchor" href="#二、锁消除"><span>二、锁消除</span></a></h2><p>锁消除指的是虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。</p><p>锁消除判定依据来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其它线程访问到，那就可以把它当作栈上数据对待，认为他们是线程私有的，同步加锁自然就无须进行。</p><p>引申出一个问题就是，变量是否逃逸，对于虚拟机来说是需要使用复杂的过程间分析才能确定的，但是程序员自己应该清楚，怎么会明知道不存在数据争用的情况下还要求同步呢——答案是，有许多同步措施并不是程序员自己加入的，Java里面同步的代码出现得很频繁，比如下面这个看起来没有同步的代码。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> concatString</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> s1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> s2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> s3){</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> s1</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">s2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">s3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于String是一个不可变的类，对字符串的连接操作总是通过生成新的String对象来进行的。上面代码经过Javac编译后，会变成下面代码的例子。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> concatString</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> s1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> s2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> s3){</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    StringBuilder</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> sb</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> StringBuilder</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    sb</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">append</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(s1);</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    sb</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">append</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(s2);</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    sb</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">append</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(s3);</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> sb</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toString</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每个StringBuilder.append()方法中都有一个同步款，锁就是sb对象。虚拟机观察变量sb，经过逃逸分析后发现它的动态作用域被限制在concatString()方法内部，也就是说sb的所有引用都永远不会逃逸到concatString()方法之外，其它线程无法访问到它，所以这里虽然有锁，但是可以被安全地消除掉。</p><h2 id="三、锁粗化" tabindex="-1"><a class="header-anchor" href="#三、锁粗化"><span>三、锁粗化</span></a></h2><p>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽可能短，但是大某些情况下，一个程序对同一个锁不间断、高频地请求、同步与释放，会消耗掉一定的系统资源，因为锁的讲求、同步与释放本身会带来性能损耗，这样高频的锁请求就反而不利于系统性能的优化了，虽然单次同步操作的时间可能很短。<strong>锁粗化就是告诉我们任何事情都有个度，有些情况下我们反而希望把很多次锁的请求合并成一个请求，以降低短时间内大量锁请求、同步、释放带来的性能损耗</strong>。</p><p><strong>情况1</strong></p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> doSomethingMethod</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(){</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    synchronized</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(lock){</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        //do some thing</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    //这是还有一些代码，做其它不需要同步的工作，但能很快执行完毕</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    synchronized</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(lock){</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        //do other thing</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码是有两块需要同步操作的，但在这两块需要同步操作的代码之间，需要做一些其它的工作，而这些工作只会花费很少的时间，那么我们就可以把这些工作代码放入锁内，将两个同步代码块合并成一个，以降低多次锁请求、同步、释放带来的系统性能消耗，合并后的代码如下:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> doSomethingMethod</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(){</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    //进行锁粗化：整合成一次锁请求、同步、释放</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    synchronized</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(lock){</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        //do some thing</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        //做其它不需要同步但能很快执行完的工作</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        //do other thing</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>情况2：加锁操作在循环体中</strong></p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">i</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">size</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">){</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    synchronized</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(lock){</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>锁粗化后代码如下</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">synchronized</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(lock){</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">i</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">size</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">){</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="四、轻量级锁" tabindex="-1"><a class="header-anchor" href="#四、轻量级锁"><span>四、轻量级锁</span></a></h2><p>“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言，因此传统的锁机制就被称为“重量级锁”，不过，需要强调一点，轻量级锁并不是用来代替重量级锁的，它的<strong>目的</strong>是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能损耗。</p><p>要理解轻量级锁，首先要理解对象头。</p><h3 id="_1、对象头" tabindex="-1"><a class="header-anchor" href="#_1、对象头"><span>1、对象头</span></a></h3><p>对象头分为两部分</p><ul><li>Mark Word。用于存储对象自身的运行时的数据，如哈希码、GC分代年龄等。</li><li>用于存储指向方法区对象类型数据的指针。</li></ul><p>对象头结构如下</p><figure><img src="'+l+'" alt="对象头结构" tabindex="0" loading="lazy"><figcaption>对象头结构</figcaption></figure><h3 id="_2、轻量级锁加锁过程" tabindex="-1"><a class="header-anchor" href="#_2、轻量级锁加锁过程"><span>2、轻量级锁加锁过程</span></a></h3><figure><img src="'+e+'" alt="轻量级锁加锁过程" tabindex="0" loading="lazy"><figcaption>轻量级锁加锁过程</figcaption></figure><h3 id="_3、轻量级锁解锁过程" tabindex="-1"><a class="header-anchor" href="#_3、轻量级锁解锁过程"><span>3、轻量级锁解锁过程</span></a></h3><p>轻量级锁解锁过程同样是通过CAS操作来进行的（因为上面轻量级锁加锁的第一步将对象的mark word拷贝到了线程的栈帧里面，所以解锁就是将栈帧里面的Displaced Mark Word替换回对象的Mark Word），如果对象的mark word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来，假如能成功替换，那整个同步过程就顺利完成了；如果替换失败，就说明有其它线程尝试获取该锁，就要在释放锁的同时，唤醒被挂起的线程。</p><h3 id="_4、轻量级锁性能" tabindex="-1"><a class="header-anchor" href="#_4、轻量级锁性能"><span>4、轻量级锁性能</span></a></h3><p>轻量级锁能提升程序同步性能的依据是“对于绝大部份的锁，在整个同步周期内都是不存在竞争的”这条法则。如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销；但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。</p>',41)]))}]]),p=JSON.parse('{"path":"/%E4%BA%8C%E3%80%81JVM/2.9%20%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/2.9.3%20%E9%94%81%E4%BC%98%E5%8C%96.html","title":"2.9.3 锁优化","lang":"zh-CN","frontmatter":{"\x3c!--cover":"/assets/images/cover2.jpg--\x3e","icon":"pen-to-square","date":"2024-11-10T00:00:00.000Z","category":["线程安全的实现方法"],"tag":["锁优化","锁消除","锁膨胀","轻量级锁"],"star":true,"ticky":true,"description":"2.9.3 锁优化 有哪些锁优化技术？ 自适应自旋 锁消除 锁膨胀 轻量级锁 一、自旋锁与自适应锁 互斥同步对性能最大的影响是阻塞的实现，挂起和恢复线程操作都需要转入内核态中完成。 自旋锁：如果有多个处理器核心，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一会儿”，但不放弃处理器的执行时间，看看持有锁的线程释放很快就会释放锁...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/myBlog/%E4%BA%8C%E3%80%81JVM/2.9%20%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/2.9.3%20%E9%94%81%E4%BC%98%E5%8C%96.html"}],["meta",{"property":"og:site_name","content":"Java笔记"}],["meta",{"property":"og:title","content":"2.9.3 锁优化"}],["meta",{"property":"og:description","content":"2.9.3 锁优化 有哪些锁优化技术？ 自适应自旋 锁消除 锁膨胀 轻量级锁 一、自旋锁与自适应锁 互斥同步对性能最大的影响是阻塞的实现，挂起和恢复线程操作都需要转入内核态中完成。 自旋锁：如果有多个处理器核心，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一会儿”，但不放弃处理器的执行时间，看看持有锁的线程释放很快就会释放锁..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-10T10:41:14.000Z"}],["meta",{"property":"article:tag","content":"锁优化"}],["meta",{"property":"article:tag","content":"锁消除"}],["meta",{"property":"article:tag","content":"锁膨胀"}],["meta",{"property":"article:tag","content":"轻量级锁"}],["meta",{"property":"article:published_time","content":"2024-11-10T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-10T10:41:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"2.9.3 锁优化\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-10T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-10T10:41:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"冉庆\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"一、自旋锁与自适应锁","slug":"一、自旋锁与自适应锁","link":"#一、自旋锁与自适应锁","children":[]},{"level":2,"title":"二、锁消除","slug":"二、锁消除","link":"#二、锁消除","children":[]},{"level":2,"title":"三、锁粗化","slug":"三、锁粗化","link":"#三、锁粗化","children":[]},{"level":2,"title":"四、轻量级锁","slug":"四、轻量级锁","link":"#四、轻量级锁","children":[{"level":3,"title":"1、对象头","slug":"_1、对象头","link":"#_1、对象头","children":[]},{"level":3,"title":"2、轻量级锁加锁过程","slug":"_2、轻量级锁加锁过程","link":"#_2、轻量级锁加锁过程","children":[]},{"level":3,"title":"3、轻量级锁解锁过程","slug":"_3、轻量级锁解锁过程","link":"#_3、轻量级锁解锁过程","children":[]},{"level":3,"title":"4、轻量级锁性能","slug":"_4、轻量级锁性能","link":"#_4、轻量级锁性能","children":[]}]}],"git":{"createdTime":1731235274000,"updatedTime":1731235274000,"contributors":[{"name":"ranqing","email":"2516488782@qq.com","commits":1}]},"readingTime":{"minutes":6.25,"words":1876},"filePathRelative":"二、JVM/2.9 线程安全与锁优化/2.9.3 锁优化.md","localizedDate":"2024年11月10日","excerpt":"\\n<p>有哪些锁优化技术？</p>\\n<ul>\\n<li>自适应自旋</li>\\n<li>锁消除</li>\\n<li>锁膨胀</li>\\n<li>轻量级锁</li>\\n</ul>\\n<h2>一、自旋锁与自适应锁</h2>\\n<p>互斥同步对性能最大的影响是阻塞的实现，挂起和恢复线程操作都需要转入内核态中完成。</p>\\n<p><strong>自旋锁</strong>：如果有多个处理器核心，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一会儿”，但不放弃处理器的执行时间，看看持有锁的线程释放很快就会释放锁。为了让线程等待，我们只须让线程执行一个忙循环（自旋）。</p>\\n<p>自旋不能代替阻塞，先不说对处理器的要求，自旋等待本身虽然避免了线程切换的开销，但它要占用处理器的时间。如果锁占用的时间很短，自旋等待的效果就会非常好，反之，带来性能浪费。因此自旋等待时间必须有一定的限度，自旋次数的默认值是10次，用户也可以使用JVM参数自行更改。</p>","autoDesc":true}')}}]);