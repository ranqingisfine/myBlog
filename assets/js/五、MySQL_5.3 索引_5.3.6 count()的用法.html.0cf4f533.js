"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4431],{6262:(e,t)=>{t.A=(e,t)=>{const o=e.__vccOpts||e;for(const[e,n]of t)o[e]=n;return o}},2824:(e,t,o)=>{o.r(t),o.d(t,{comp:()=>r,data:()=>i});var n=o(641);const c=o.p+"assets/img/a19.887c4546.png",a={},r=(0,o(6262).A)(a,[["render",function(e,t){return(0,n.uX)(),(0,n.CE)("div",null,t[0]||(t[0]=[(0,n.Fv)('<h1 id="_5-3-6-count-的用法" tabindex="-1"><a class="header-anchor" href="#_5-3-6-count-的用法"><span>5.3.6 count()的用法</span></a></h1><p>先说结论</p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在InnoDB中<code>COUNT(*)</code>和<code>COUNT(1)</code>实现上没有区别，而且效率一样，但是<code>COUNT(字段)</code>需要进行字段的非NULL判断，所以效率会低一些。</p><h2 id="一、count" tabindex="-1"><a class="header-anchor" href="#一、count"><span>一、count(*)</span></a></h2><p><strong>MyISAM</strong>做了一个简单的优化，把表的总行数单独记录下来，如果执行<code>count(*)</code>时可以直接返回，前提是不能有where条件。MyISAM是表级锁，不会有并发的行操作，所以查到的结果是准确的。</p><p><strong>InnoDB</strong>不能使用这种缓存操作，因为支持事务，大部分操作都是行级锁，行可能被并行修改，那么缓存记录不准确。但是，InnoDB还是针对COUNT(*)语句做了些优化的。InnoDB中索引分为聚簇索引（主键索引）和非聚簇索引（非主键索引），聚簇索引的叶子节点中保存的是整行记录，而非聚簇索引的叶子节点中保存的是该行记录的主键的值。</p><h2 id="二、count-1" tabindex="-1"><a class="header-anchor" href="#二、count-1"><span>二、count(1)</span></a></h2><p>对于<code>count(1)</code>和<code>count(*)</code>，MySQL的优化是完全一样的，根本不存在谁更快！但依旧建议使用<code>count(*)</code>，因为这是SQL92定义的标准统计行数的语法。</p><h2 id="三、count-字段" tabindex="-1"><a class="header-anchor" href="#三、count-字段"><span>三、count(字段)</span></a></h2><p>进行全表扫描，判断指定字段的值是否为<code>NULL</code>，不为<code>NULL</code>则累加。性能比<code>count(1)</code>和<code>count(*)</code>慢。</p>',11)]))}]]),i=JSON.parse('{"path":"/%E4%BA%94%E3%80%81MySQL/5.3%20%E7%B4%A2%E5%BC%95/5.3.6%20count()%E7%9A%84%E7%94%A8%E6%B3%95.html","title":"5.3.6 count()的用法","lang":"zh-CN","frontmatter":{"\x3c!--cover":"/assets/images/cover2.jpg--\x3e","icon":"pen-to-square","date":"2024-11-17T00:00:00.000Z","category":["MySQL","索引"],"tag":["count()用法"],"star":true,"ticky":true,"description":"5.3.6 count()的用法 先说结论 在InnoDB中COUNT(*)和COUNT(1)实现上没有区别，而且效率一样，但是COUNT(字段)需要进行字段的非NULL判断，所以效率会低一些。 一、count(*) MyISAM做了一个简单的优化，把表的总行数单独记录下来，如果执行count(*)时可以直接返回，前提是不能有where条件。MyISA...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/myBlog/%E4%BA%94%E3%80%81MySQL/5.3%20%E7%B4%A2%E5%BC%95/5.3.6%20count()%E7%9A%84%E7%94%A8%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"Java笔记"}],["meta",{"property":"og:title","content":"5.3.6 count()的用法"}],["meta",{"property":"og:description","content":"5.3.6 count()的用法 先说结论 在InnoDB中COUNT(*)和COUNT(1)实现上没有区别，而且效率一样，但是COUNT(字段)需要进行字段的非NULL判断，所以效率会低一些。 一、count(*) MyISAM做了一个简单的优化，把表的总行数单独记录下来，如果执行count(*)时可以直接返回，前提是不能有where条件。MyISA..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-17T05:34:20.000Z"}],["meta",{"property":"article:tag","content":"count()用法"}],["meta",{"property":"article:published_time","content":"2024-11-17T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-17T05:34:20.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"5.3.6 count()的用法\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-17T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-17T05:34:20.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"冉庆\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"一、count(*)","slug":"一、count","link":"#一、count","children":[]},{"level":2,"title":"二、count(1)","slug":"二、count-1","link":"#二、count-1","children":[]},{"level":2,"title":"三、count(字段)","slug":"三、count-字段","link":"#三、count-字段","children":[]}],"git":{"createdTime":1731821660000,"updatedTime":1731821660000,"contributors":[{"name":"ranqing","email":"2516488782@qq.com","commits":1}]},"readingTime":{"minutes":1.21,"words":362},"filePathRelative":"五、MySQL/5.3 索引/5.3.6 count()的用法.md","localizedDate":"2024年11月17日","excerpt":"\\n<p>先说结论</p>\\n<figure><figcaption></figcaption></figure>\\n<p>在InnoDB中<code>COUNT(*)</code>和<code>COUNT(1)</code>实现上没有区别，而且效率一样，但是<code>COUNT(字段)</code>需要进行字段的非NULL判断，所以效率会低一些。</p>\\n<h2>一、count(*)</h2>\\n<p><strong>MyISAM</strong>做了一个简单的优化，把表的总行数单独记录下来，如果执行<code>count(*)</code>时可以直接返回，前提是不能有where条件。MyISAM是表级锁，不会有并发的行操作，所以查到的结果是准确的。</p>","autoDesc":true}')}}]);