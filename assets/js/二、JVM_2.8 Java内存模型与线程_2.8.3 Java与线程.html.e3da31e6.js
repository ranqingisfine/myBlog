"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[6528],{66262:(a,e)=>{e.A=(a,e)=>{const t=a.__vccOpts||a;for(const[a,r]of e)t[a]=r;return t}},78028:(a,e,t)=>{t.r(e),t.d(e,{comp:()=>p,data:()=>l});var r=t(20641);const n={},p=(0,t(66262).A)(n,[["render",function(a,e){return(0,r.uX)(),(0,r.CE)("div",null,e[0]||(e[0]=[(0,r.Fv)('<h1 id="_2-8-3-java与线程" tabindex="-1"><a class="header-anchor" href="#_2-8-3-java与线程"><span>2.8.3 Java与线程</span></a></h1><p>进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。Thread所有关键方法都被声明为Native。</p><p>操作系统实现线程的三种方式：</p><ul><li>使用内核线程实现（线程和内核线程1:1实现）</li><li>使用用户线程实现（进程和用户线程1:N实现）</li><li>使用用户线程➕轻量级进程混合实现（N:M实现）</li></ul><h2 id="一、内核线程实现" tabindex="-1"><a class="header-anchor" href="#一、内核线程实现"><span>一、内核线程实现</span></a></h2><p><strong>Java线程是采用内核线程来实现的。</strong></p><p>内核线程是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。</p><p>程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口——轻量级进程（即线程）。每个线程都由一个内核线程支持，这种线程和内核线程之间1:1的关系成为一对一的线程模型。</p><p><strong>优点</strong>： 每个线程是一个独立的调度单元，即使其中某一个阻塞了，也不会影响整个进程继续工作。</p><p><strong>缺点</strong>：</p><ul><li>由于是基于内核线程实现的，所以各种线程操作如创建等，都需要进行系统调用。而系统调用的代价高，需要在用户态和内核态中来回切换，这两种状态切换开销的主要源自响应中断、保护和恢复执行现场的成本。</li><li>每个线程都需要有一个内核线程的支持，因此线程会消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持线程的数量是有限的。</li></ul><h2 id="二、用户线程实现" tabindex="-1"><a class="header-anchor" href="#二、用户线程实现"><span>二、用户线程实现</span></a></h2><p>用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知用户线程的存在以及如何实现的。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。</p><p>如果程序实现得当，这种线程不需要切换到内核态，因此操作快、消耗低，能支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。</p><p>**缺点：**没有系统内核的支援，所有的线程操作都需要由用户程序自己去处理。</p><p>以高并发为卖点的编程语言如：Golang、Erlang等，普遍使用了用户线程实现。</p><h2 id="三、混合实现" tabindex="-1"><a class="header-anchor" href="#三、混合实现"><span>三、混合实现</span></a></h2><p>即存在用户线程也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换等操作依然廉价，并且支持大规模的并发。而操作系统的轻量级进程作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能以及处理器映射，并且用户线程的系统调度要通过轻量级进程来完成，大大降低了整个进程被完全阻塞的风险</p><h2 id="四、java线程调度" tabindex="-1"><a class="header-anchor" href="#四、java线程调度"><span>四、Java线程调度</span></a></h2><p>线程调度指处理器为线程分配处理器使用权的过程，调度主要有两种方式：<strong>协同式和抢占式</strong>线程调度。</p><blockquote><p>协同式线程调度</p></blockquote><p>协同式线程调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完成后，要主动通知系统切换到另外一个线程上去。</p><p><strong>优点</strong>：因为线程干完后才切换，所以一般没有线程同步的问题。例如Lua语言中的“协同例程”就是这类实现。</p><p><strong>缺点</strong>：线程执行时间不可控，如果一个线程编码有问题，一直不告知系统切换，那么程序会一直阻塞在那里。</p><blockquote><p>抢占式调度</p></blockquote><p>如果使用抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程切换不由线程本身来决定。例如Java中Thread.yield()方法可以主动让出执行时间，但是如果想要主动获取执行时间，线程本身是没有什么方法的。</p><p>Java使用的线程调度方式就是抢占式调度。</p><p>虽然Java线程调度是系统自动完成的，但是我们还是可以建议操作系统给某些线程多分配一点执行时间。Java语言设置了10个级别的线程优先级。不过线程优先级并不是一项稳定的手段，线程调度还是由操作系统说了算。</p><h2 id="五、状态转换" tabindex="-1"><a class="header-anchor" href="#五、状态转换"><span>五、状态转换</span></a></h2><ul><li>新建</li><li>运行</li><li>无限期等待</li><li>有限等待</li><li>阻塞</li><li>结束</li></ul>',30)]))}]]),l=JSON.parse('{"path":"/%E4%BA%8C%E3%80%81JVM/2.8%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2.8.3%20Java%E4%B8%8E%E7%BA%BF%E7%A8%8B.html","title":"2.8.3 Java与线程","lang":"zh-CN","frontmatter":{"\x3c!--cover":"/assets/images/cover2.jpg--\x3e","icon":"pen-to-square","date":"2024-11-06T00:00:00.000Z","category":["JVM","Java内存模型与线程"],"tag":["内核线程实现","用户线程实现","混合实现","线程调度","状态转换"],"star":true,"ticky":true,"description":"2.8.3 Java与线程 进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。Thread所有关键方法都被声明为Native。 操作系统实现线程的三种方式： 使用内核线程实现（线程和内核线程1:1实现） 使用用户线程实现（进程和用户线程1:N实现） 使用用户线程➕轻量级进程混合实现（N:M实现） 一、内核线程实现 Java线程是采用内核线...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/myBlog/%E4%BA%8C%E3%80%81JVM/2.8%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2.8.3%20Java%E4%B8%8E%E7%BA%BF%E7%A8%8B.html"}],["meta",{"property":"og:site_name","content":"Java笔记"}],["meta",{"property":"og:title","content":"2.8.3 Java与线程"}],["meta",{"property":"og:description","content":"2.8.3 Java与线程 进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。Thread所有关键方法都被声明为Native。 操作系统实现线程的三种方式： 使用内核线程实现（线程和内核线程1:1实现） 使用用户线程实现（进程和用户线程1:N实现） 使用用户线程➕轻量级进程混合实现（N:M实现） 一、内核线程实现 Java线程是采用内核线..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-08T02:56:46.000Z"}],["meta",{"property":"article:tag","content":"内核线程实现"}],["meta",{"property":"article:tag","content":"用户线程实现"}],["meta",{"property":"article:tag","content":"混合实现"}],["meta",{"property":"article:tag","content":"线程调度"}],["meta",{"property":"article:tag","content":"状态转换"}],["meta",{"property":"article:published_time","content":"2024-11-06T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-08T02:56:46.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"2.8.3 Java与线程\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-06T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-08T02:56:46.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"冉庆\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"一、内核线程实现","slug":"一、内核线程实现","link":"#一、内核线程实现","children":[]},{"level":2,"title":"二、用户线程实现","slug":"二、用户线程实现","link":"#二、用户线程实现","children":[]},{"level":2,"title":"三、混合实现","slug":"三、混合实现","link":"#三、混合实现","children":[]},{"level":2,"title":"四、Java线程调度","slug":"四、java线程调度","link":"#四、java线程调度","children":[]},{"level":2,"title":"五、状态转换","slug":"五、状态转换","link":"#五、状态转换","children":[]}],"git":{"createdTime":1730899236000,"updatedTime":1731034606000,"contributors":[{"name":"ranqing","email":"2516488782@qq.com","commits":1}]},"readingTime":{"minutes":4.32,"words":1295},"filePathRelative":"二、JVM/2.8 Java内存模型与线程/2.8.3 Java与线程.md","localizedDate":"2024年11月6日","excerpt":"\\n<p>进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。Thread所有关键方法都被声明为Native。</p>\\n<p>操作系统实现线程的三种方式：</p>\\n<ul>\\n<li>使用内核线程实现（线程和内核线程1:1实现）</li>\\n<li>使用用户线程实现（进程和用户线程1:N实现）</li>\\n<li>使用用户线程➕轻量级进程混合实现（N:M实现）</li>\\n</ul>\\n<h2>一、内核线程实现</h2>\\n<p><strong>Java线程是采用内核线程来实现的。</strong></p>\\n<p>内核线程是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。</p>","autoDesc":true}')}}]);