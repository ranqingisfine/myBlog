"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4962],{6262:(e,t)=>{t.A=(e,t)=>{const a=e.__vccOpts||e;for(const[e,i]of t)a[e]=i;return a}},5322:(e,t,a)=>{a.r(t),a.d(t,{comp:()=>n,data:()=>r});var i=a(641);const l={},n=(0,a(6262).A)(l,[["render",function(e,t){return(0,i.uX)(),(0,i.CE)("div",null,t[0]||(t[0]=[(0,i.Fv)('<h1 id="_2-8-4-java与协程" tabindex="-1"><a class="header-anchor" href="#_2-8-4-java与协程"><span>2.8.4 Java与协程</span></a></h1><h2 id="一、线程的缺陷" tabindex="-1"><a class="header-anchor" href="#一、线程的缺陷"><span>一、线程的缺陷</span></a></h2><p>在理解虚拟线程前，我们先回顾一下线程的特点：</p><ul><li>线程是由操作系统创建并调度的资源；</li><li>线程切换会耗费大量CPU时间；</li><li>一个系统能同时调度的线程数量是有限的，通常在几百至几千级别。</li></ul><p>因此，我们说线程是一种重量级资源。在服务器端，对用户请求，通常都实现为一个线程处理一个请求。由于用户的请求数往往远超操作系统能同时调度的线程数量，所以通常使用线程池来尽量减少频繁创建和销毁线程的成本</p><p>对于需要处理大量IO请求的任务来说，使用线程是低效的，因为一旦读写IO，线程就必须进入等待状态，直到IO数据返回。常见的IO操作包括：</p><ul><li>读写文件；</li><li>读写网络，例如HTTP请求；</li><li>读写数据库，本质上是通过JDBC实现网络调用。</li></ul><h2 id="二、协程" tabindex="-1"><a class="header-anchor" href="#二、协程"><span>二、协程</span></a></h2><ul><li><strong>协程</strong>是一种比线程更加轻量级的存在，一个进程可以拥有多个线程，一个线程也可以拥有多个协程。</li><li>协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程那样需要上下文切换来消耗资源，因此<strong>协程的开销远远小于线程的开销</strong>。</li></ul><p><strong>优点</strong>：协程比传统内核线程要轻量得多</p><p><strong>缺点</strong>：程序实现内容更多比如调用栈、调度器。</p><p>由于协程会完整地做调用栈的保护、恢复工作，所以今天也被称为“有栈线程”。对于有栈线程，Java有一种特例实现名为纤程。</p><p>纤程并发代码分为两部分：</p><ul><li>执行过程。维护执行现场，保护、恢复上下文状态</li><li>调度器。负责编排所有要执行的代码的顺序</li></ul><h2 id="三、jdk19协程" tabindex="-1"><a class="header-anchor" href="#三、jdk19协程"><span>三、JDK19协程</span></a></h2><p>JDK19（非LTS版本）正式引入协程。</p><p>为了能高效执行IO密集型任务，Java从19开始引入了虚拟线程。虚拟线程的接口和普通线程是一样的，但是执行方式不一样。虚拟线程不是由操作系统调度，而是由普通线程调度，即成百上千个虚拟线程可以由一个普通线程调度。任何时刻，只能执行一个虚拟线程，但是，一旦该虚拟线程执行一个IO操作进入等待时，它会被立刻“挂起”，然后执行下一个虚拟线程。什么时候IO数据返回了，这个挂起的虚拟线程才会被再次调度。因此，若干个虚拟线程可以在一个普通线程中交替运行</p><ul><li><p>Java 19引入的虚拟线程是为了解决IO密集型任务的吞吐量，它可以高效通过少数线程去调度大量虚拟线程；</p></li><li><p>虚拟线程在执行到IO操作或Blocking操作时，会自动切换到其他虚拟线程执行，从而避免当前线程等待，能最大化线程的执行效率；</p></li><li><p>虚拟线程使用普通线程相同的接口，最大的好处是无需修改任何代码，就可以将现有的IO操作异步化获得更大的吞吐能力。</p></li><li><p>计算密集型任务不应使用虚拟线程，只能通过增加CPU核心解决，或者利用分布式计算资源。</p></li></ul>',18)]))}]]),r=JSON.parse('{"path":"/%E4%BA%8C%E3%80%81JVM/2.8%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2.8.4%20Java%E4%B8%8E%E5%8D%8F%E7%A8%8B.html","title":"2.8.4 Java与协程","lang":"zh-CN","frontmatter":{"\x3c!--cover":"/assets/images/cover2.jpg--\x3e","icon":"pen-to-square","date":"2024-11-07T00:00:00.000Z","category":["JVM","Java内存模型与线程"],"tag":["线程缺陷","协程"],"star":true,"ticky":true,"description":"2.8.4 Java与协程 一、线程的缺陷 在理解虚拟线程前，我们先回顾一下线程的特点： 线程是由操作系统创建并调度的资源； 线程切换会耗费大量CPU时间； 一个系统能同时调度的线程数量是有限的，通常在几百至几千级别。 因此，我们说线程是一种重量级资源。在服务器端，对用户请求，通常都实现为一个线程处理一个请求。由于用户的请求数往往远超操作系统能同时调度...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/myBlog/%E4%BA%8C%E3%80%81JVM/2.8%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2.8.4%20Java%E4%B8%8E%E5%8D%8F%E7%A8%8B.html"}],["meta",{"property":"og:site_name","content":"Java笔记"}],["meta",{"property":"og:title","content":"2.8.4 Java与协程"}],["meta",{"property":"og:description","content":"2.8.4 Java与协程 一、线程的缺陷 在理解虚拟线程前，我们先回顾一下线程的特点： 线程是由操作系统创建并调度的资源； 线程切换会耗费大量CPU时间； 一个系统能同时调度的线程数量是有限的，通常在几百至几千级别。 因此，我们说线程是一种重量级资源。在服务器端，对用户请求，通常都实现为一个线程处理一个请求。由于用户的请求数往往远超操作系统能同时调度..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-08T02:56:46.000Z"}],["meta",{"property":"article:tag","content":"线程缺陷"}],["meta",{"property":"article:tag","content":"协程"}],["meta",{"property":"article:published_time","content":"2024-11-07T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-08T02:56:46.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"2.8.4 Java与协程\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-07T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-08T02:56:46.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"冉庆\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"一、线程的缺陷","slug":"一、线程的缺陷","link":"#一、线程的缺陷","children":[]},{"level":2,"title":"二、协程","slug":"二、协程","link":"#二、协程","children":[]},{"level":2,"title":"三、JDK19协程","slug":"三、jdk19协程","link":"#三、jdk19协程","children":[]}],"git":{"createdTime":1730948675000,"updatedTime":1731034606000,"contributors":[{"name":"ranqing","email":"2516488782@qq.com","commits":1}]},"readingTime":{"minutes":3.18,"words":954},"filePathRelative":"二、JVM/2.8 Java内存模型与线程/2.8.4 Java与协程.md","localizedDate":"2024年11月7日","excerpt":"\\n<h2>一、线程的缺陷</h2>\\n<p>在理解虚拟线程前，我们先回顾一下线程的特点：</p>\\n<ul>\\n<li>线程是由操作系统创建并调度的资源；</li>\\n<li>线程切换会耗费大量CPU时间；</li>\\n<li>一个系统能同时调度的线程数量是有限的，通常在几百至几千级别。</li>\\n</ul>\\n<p>因此，我们说线程是一种重量级资源。在服务器端，对用户请求，通常都实现为一个线程处理一个请求。由于用户的请求数往往远超操作系统能同时调度的线程数量，所以通常使用线程池来尽量减少频繁创建和销毁线程的成本</p>\\n<p>对于需要处理大量IO请求的任务来说，使用线程是低效的，因为一旦读写IO，线程就必须进入等待状态，直到IO数据返回。常见的IO操作包括：</p>","autoDesc":true}')}}]);