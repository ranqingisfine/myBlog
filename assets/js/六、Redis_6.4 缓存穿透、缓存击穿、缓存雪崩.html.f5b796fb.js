"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[1728],{6262:(e,t)=>{t.A=(e,t)=>{const i=e.__vccOpts||e;for(const[e,a]of t)i[e]=a;return i}},4777:(e,t,i)=>{i.r(t),i.d(t,{comp:()=>d,data:()=>c});var a=i(641);const n=i.p+"assets/img/9.dc541968.png",s=i.p+"assets/img/10.d811e1ee.webp",r=i.p+"assets/img/11.852c5277.png",p=i.p+"assets/img/12.63fa9dd4.png",l=i.p+"assets/img/13.47d1fb4d.png",o={},d=(0,i(6262).A)(o,[["render",function(e,t){return(0,a.uX)(),(0,a.CE)("div",null,t[0]||(t[0]=[(0,a.Fv)('<h1 id="_6-4-缓存穿透、缓存击穿、缓存雪崩" tabindex="-1"><a class="header-anchor" href="#_6-4-缓存穿透、缓存击穿、缓存雪崩"><span>6.4 缓存穿透、缓存击穿、缓存雪崩</span></a></h1><h2 id="一、缓存穿透" tabindex="-1"><a class="header-anchor" href="#一、缓存穿透"><span>一、缓存穿透</span></a></h2><p><strong>缓存穿透：</strong>⽤户想要查询⼀个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询，当⽤户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很⼤的压⼒，这时候就相当于出现了缓存穿透。</p><p>解决方法是：<strong>布隆过滤器</strong>和<strong>缓存空对象</strong></p><h3 id="_1、布隆过滤器" tabindex="-1"><a class="header-anchor" href="#_1、布隆过滤器"><span>1、布隆过滤器</span></a></h3><p>布隆过滤器是⼀种数据结构，对所有可能查询的参数以hash形式存储，可以用于检索一个元素是否在一个集合中，在控制层先进⾏校验，不符合则丢弃，从⽽避免了对底层存储系统的查询压⼒。</p><p>如果还是不太好理解的话，就可以把布隆过滤器理解为一个set集合，我们可以通过add往里面添加元素，通过contains来判断是否包含某个元素。</p><p><strong>用途</strong>：</p><ul><li>解决Redis缓存穿透（今天重点讲解）</li><li>在爬虫时，对爬虫网址进行过滤，已经存在布隆中的网址，不在爬取。</li><li>垃圾邮件过滤，对每一个发送邮件的地址进行判断是否在布隆的黑名单中，如果在就判断为垃圾邮件。</li></ul><p><strong>布隆过滤器存入过程原理</strong>：</p><p>布隆过滤器上面说了，就是一个二进制数据的集合。当一个数据加入这个集合时，经历如下洗礼（这里有缺点，下面会讲）：</p><ul><li>通过K个哈希函数计算该数据，返回K个计算出的hash值</li><li>这些K个hash值映射到对应的K个二进制的数组下标</li><li>将K个下标对应的二进制数据改成1。</li></ul><p>例如，第一个哈希函数返回x，第二个第三个哈希函数返回y与z，那么：X、Y、Z对应的二进制改成1。</p><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>布隆过滤器查询过程原理：</strong></p><p>布隆过滤器主要作用就是查询一个数据，在不在这个二进制的集合中，查询过程如下：</p><ul><li>通过K个哈希函数计算该数据，对应计算出的K个hash值</li><li>通过hash值找到对应的二进制的数组下标</li><li>判断：如果存在一处位置的二进制数据是0，那么该数据不存在。如果都是1，该数据存在集合中。（这里有缺点，下面会讲）</li></ul><p><strong>布隆过滤器删除过程</strong></p><p>一般不能删除布隆过滤器里的数据，这是一个缺点之一，我们下面会分析。</p><p><strong>优点</strong></p><ul><li>由于存储的是二进制数据，所以占用的空间很小</li><li>它的插入和查询速度是非常快的，时间复杂度是O（K），可以联想一下HashMap的过程</li><li>保密性很好，因为本身不存储任何原始数据，只有二进制数据</li><li>一个元素如果在布隆过滤器里判定结果为<strong>不存在，则一定不存在</strong></li></ul><p><strong>缺点</strong></p><ul><li><p>存在误判：假如上面的图没有存&quot;<code>hello</code>&quot;，只存了&quot;<code>你好</code>&quot;，那么用&quot;<code>hello</code>&quot;来查询的时候，会判断&quot;<code>hello</code>&quot;存在集合中。</p><p>因为“<code>你好</code>”和“<code>hello</code>”的hash值是相同的，通过相同的hash值，找到的二进制数据也是一样的，都是1。</p></li><li><p>删除困难</p></li></ul><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>假设我们的Redis里存有一组用户的注册email，以email作为Key存在，同时它对应着DB里的User表的部分字段。</p><p>一般来说，一个合理的请求过来我们会先在Redis里判断这个用户是否是会员，因为从缓存里读数据返回快。如果这个会员在缓存中不存在那么我们会去DB中查询一下。</p><p>现在试想，有千万个不同IP的请求（不要以为没有，我们就在2018年和2019年碰到了，因为攻击的成本很低）带着Redis里根本不存在的key来访问你的网站，这时我们来设想一下：</p><p>请求到达Web服务器； 请求派发到应用层-&gt;微服务层； 请求去Redis捞数据，Redis内不存在这个Key； 于是请求到达DB层，在DB建立connection后进行一次查询 千万乃至上亿的DB连接请求，先不说Redis是否撑的住DB也会被瞬间打爆。这就是“Redis穿透”又被称为“缓存击穿”，它会打爆你的缓存或者是连DB一起打爆进而引起一系列的“雪崩效应”。</p><p>怎么防 那就是使用布隆过滤器，可以把所有的user表里的关键查询字段放于Redis的bloom过滤器内。有人会说，这不疯了，我有4000万会员？so what！ ps：布隆过滤器另一个用途——推荐去重 例如新闻客户端的推送去重功能，当推荐系统推荐新闻时会从每个用户的历史记录里进行筛选，过滤掉那些已经存在的记录。</p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_2、缓存空对象" tabindex="-1"><a class="header-anchor" href="#_2、缓存空对象"><span>2、缓存空对象</span></a></h3><p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置⼀个过期时间，之后再访问这个数 据将会从缓存中获取，保护了后端数据源；但是这种⽅法会存在两个问题： 1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键； 2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有⼀段时间窗⼝的不⼀致，这对于 需要保持⼀致性的业务会有影响。</p><h2 id="二、缓存击穿" tabindex="-1"><a class="header-anchor" href="#二、缓存击穿"><span>二、缓存击穿</span></a></h2><p>​ <strong>缓存击穿（量太⼤，缓存过期！）：<strong>这⾥需要注意和缓存击穿的区别，缓存击穿，是指</strong>⼀个key⾮常热点</strong>，在不停的扛着⼤并发，⼤并发集中对这⼀个点进⾏访问，当这个key在失效的瞬间，持续的⼤并发就穿破缓存，直接请求数据库，就像在⼀个屏障上凿开了⼀个洞。由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压⼒过⼤。</p><p>解决方案1：设置热点数据永不过期</p><p>解决方案2：加互斥锁</p><p>​ 分布式锁：使⽤分布式锁，保证对于每个key同时只有⼀个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种⽅式将⾼并发的压⼒转移到了分布式锁，因此对分布式锁的考 验很⼤。</p><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="三、缓存雪崩" tabindex="-1"><a class="header-anchor" href="#三、缓存雪崩"><span>三、缓存雪崩</span></a></h2><p>缓存雪崩，是指在某⼀个时间段，缓存集中过期失效。Redis 宕机！</p><p>​ 产⽣雪崩的原因之⼀，⽐如在写本⽂的时候，⻢上就要到双⼗⼆零点，很快就会迎来⼀波抢购，这波商 品时间⽐较集中的放⼊了缓存，假设缓存⼀个⼩时。那么到了凌晨⼀点钟的时候，这批商品的缓存就都 过期了。⽽对这批商品的访问查询，都落到了数据库上，对于数据库⽽⾔，就会产⽣周期性的压⼒波 峰。于是所有的请求都会达到存储层，存储层的调⽤量会暴增，造成存储层也会挂掉的情况。</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>解决方案：</p><h3 id="redis高可用" tabindex="-1"><a class="header-anchor" href="#redis高可用"><span>redis高可用</span></a></h3><p>​ 这个思想的含义是，既然redis有可能挂掉，那我多增设⼏台redis，这样⼀台挂掉之后其他的还可以继续⼯作，其实就是搭建的集群。（异地多活！）</p><h3 id="限流降级-在springcloud讲解过" tabindex="-1"><a class="header-anchor" href="#限流降级-在springcloud讲解过"><span>限流降级（在SpringCloud讲解过！）</span></a></h3><p>​ 这个解决⽅案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。⽐如对 某个key只允许⼀个线程查询数据和写缓存，其他线程等待。（Java并发里面的<strong>控制并发线程数Semaphore</strong>)</p><h3 id="数据预热" tabindex="-1"><a class="header-anchor" href="#数据预热"><span>数据预热</span></a></h3><p>​ 数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问⼀遍，这样部分可能⼤量访问的数 据就会加载到缓存中。在即将发⽣⼤并发访问前⼿动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>',49)]))}]]),c=JSON.parse('{"path":"/%E5%85%AD%E3%80%81Redis/6.4%20%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9.html","title":"6.4 缓存穿透、缓存击穿、缓存雪崩","lang":"zh-CN","frontmatter":{"\x3c!--cover":"/assets/images/cover2.jpg--\x3e","icon":"pen-to-square","date":"2024-11-19T00:00:00.000Z","category":["Redis"],"tag":["缓存穿透","缓存击穿","缓存雪崩"],"star":true,"ticky":true,"description":"6.4 缓存穿透、缓存击穿、缓存雪崩 一、缓存穿透 缓存穿透：⽤户想要查询⼀个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询，当⽤户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很⼤的压⼒，这时候就相当于出现了缓存穿透。 解决方法是：布隆过滤器和缓存空对象 1、布隆过滤器 布隆过滤器是⼀种...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/myBlog/%E5%85%AD%E3%80%81Redis/6.4%20%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9.html"}],["meta",{"property":"og:site_name","content":"Java笔记"}],["meta",{"property":"og:title","content":"6.4 缓存穿透、缓存击穿、缓存雪崩"}],["meta",{"property":"og:description","content":"6.4 缓存穿透、缓存击穿、缓存雪崩 一、缓存穿透 缓存穿透：⽤户想要查询⼀个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询，当⽤户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很⼤的压⼒，这时候就相当于出现了缓存穿透。 解决方法是：布隆过滤器和缓存空对象 1、布隆过滤器 布隆过滤器是⼀种..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-19T02:38:11.000Z"}],["meta",{"property":"article:tag","content":"缓存穿透"}],["meta",{"property":"article:tag","content":"缓存击穿"}],["meta",{"property":"article:tag","content":"缓存雪崩"}],["meta",{"property":"article:published_time","content":"2024-11-19T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-19T02:38:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"6.4 缓存穿透、缓存击穿、缓存雪崩\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-19T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-19T02:38:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"冉庆\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"一、缓存穿透","slug":"一、缓存穿透","link":"#一、缓存穿透","children":[{"level":3,"title":"1、布隆过滤器","slug":"_1、布隆过滤器","link":"#_1、布隆过滤器","children":[]},{"level":3,"title":"2、缓存空对象","slug":"_2、缓存空对象","link":"#_2、缓存空对象","children":[]}]},{"level":2,"title":"二、缓存击穿","slug":"二、缓存击穿","link":"#二、缓存击穿","children":[]},{"level":2,"title":"三、缓存雪崩","slug":"三、缓存雪崩","link":"#三、缓存雪崩","children":[{"level":3,"title":"redis高可用","slug":"redis高可用","link":"#redis高可用","children":[]},{"level":3,"title":"限流降级（在SpringCloud讲解过！）","slug":"限流降级-在springcloud讲解过","link":"#限流降级-在springcloud讲解过","children":[]},{"level":3,"title":"数据预热","slug":"数据预热","link":"#数据预热","children":[]}]}],"git":{"createdTime":1731983891000,"updatedTime":1731983891000,"contributors":[{"name":"ranqing","email":"2516488782@qq.com","commits":1}]},"readingTime":{"minutes":7.19,"words":2156},"filePathRelative":"六、Redis/6.4 缓存穿透、缓存击穿、缓存雪崩.md","localizedDate":"2024年11月19日","excerpt":"\\n<h2>一、缓存穿透</h2>\\n<p><strong>缓存穿透：</strong>⽤户想要查询⼀个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询，当⽤户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很⼤的压⼒，这时候就相当于出现了缓存穿透。</p>\\n<p>解决方法是：<strong>布隆过滤器</strong>和<strong>缓存空对象</strong></p>\\n<h3>1、布隆过滤器</h3>\\n<p>布隆过滤器是⼀种数据结构，对所有可能查询的参数以hash形式存储，可以用于检索一个元素是否在一个集合中，在控制层先进⾏校验，不符合则丢弃，从⽽避免了对底层存储系统的查询压⼒。</p>","autoDesc":true}')}}]);