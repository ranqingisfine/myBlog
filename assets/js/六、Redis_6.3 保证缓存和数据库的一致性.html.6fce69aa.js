"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5466],{6262:(e,t)=>{t.A=(e,t)=>{const a=e.__vccOpts||e;for(const[e,n]of t)a[e]=n;return a}},4792:(e,t,a)=>{a.r(t),a.d(t,{comp:()=>s,data:()=>c});var n=a(641);const r=a.p+"assets/img/6.c8e4bda9.png",i=a.p+"assets/img/7.61a678da.png",p=a.p+"assets/img/8.777e4d41.png",o={},s=(0,a(6262).A)(o,[["render",function(e,t){return(0,n.uX)(),(0,n.CE)("div",null,t[0]||(t[0]=[(0,n.Fv)('<h1 id="_6-3-保证缓存和数据库的一致性" tabindex="-1"><a class="header-anchor" href="#_6-3-保证缓存和数据库的一致性"><span>6.3 保证缓存和数据库的一致性</span></a></h1><h2 id="一、只读场景" tabindex="-1"><a class="header-anchor" href="#一、只读场景"><span>一、只读场景</span></a></h2><p><strong>注意</strong>：单独的只读去数据场景是不会出现不一致。只有读和写在一起才会出现。</p><p>逻辑如下：</p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>1、当应用程序需要从数据库读取数据时，先检查缓存数据是否命中。 2、如果缓存命中，则查下数据库获取数据，同时将数据写到缓存中并设置过期时间，以便后续读取相同数据会命中缓存，最后再把数据返回给调用者。 3、如果缓存命中，直接返回。</p><h2 id="二、并发读写数据场景" tabindex="-1"><a class="header-anchor" href="#二、并发读写数据场景"><span>二、并发读写数据场景</span></a></h2><p><strong>先操作数据库再操作缓存</strong></p><figure><img src="'+i+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>线程1先修改数据库，修改过程中线程2查询数据，查的是老数据，然后返回。线程1最终会删掉redis，然后下一个线程进来，查到redis中没有，会把数据库中查询的新数据更新到redis，能保证最终一致性。所以更推荐先操作数据库，再操作缓存。</p><p>​ 缺点是操作数据库的时候，其他线程进来查到的是修改前的脏数据，但最终还是保证了数据的最终一致性。</p><p>​ <strong>先操作数据库再操作缓存还是存在问题，问题是删除缓存的时候失败了</strong>，后面一直查到的都是老数据，必须要等待redis过期之后才能查到新数据。</p><p>​ 针对删除失败的情况，可以采用删除重试的机制。</p><h3 id="_1、删除缓存重试机制" tabindex="-1"><a class="header-anchor" href="#_1、删除缓存重试机制"><span>1、删除缓存重试机制</span></a></h3><p>如果删除缓存失败怎么办？比如延迟双删的第二次删除失败，那岂不是无法删除脏数据。</p><p>使用重试机制，保证删除缓存成功。</p><p>比如重试3次，3次都失败则记录日志到数据库并发送警告让人工介入，在高并发的场景下，<strong>重试最好使用异步方式</strong>，比如发送消息到mq中间件，实现异步解耦。</p><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>第（6）步如果删除失败且未达到重试最大次数则将消息重新如对，直到删除成功，否则就记录到数据库，人工介入。</p><p>该方法有个<strong>缺点</strong>，就是<strong>对业务代码中造成侵入，代码过于耦合</strong>。如果要实现解耦的话，那么采用canal组件canal读取binlog异步删除。</p>',20)]))}]]),c=JSON.parse('{"path":"/%E5%85%AD%E3%80%81Redis/6.3%20%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7.html","title":"6.3 保证缓存和数据库的一致性","lang":"zh-CN","frontmatter":{"\x3c!--cover":"/assets/images/cover2.jpg--\x3e","icon":"pen-to-square","date":"2024-11-18T00:00:00.000Z","category":["Redis"],"tag":["缓存和数据库一致性","只读场景","并发读写场景"],"star":true,"ticky":true,"description":"6.3 保证缓存和数据库的一致性 一、只读场景 注意：单独的只读去数据场景是不会出现不一致。只有读和写在一起才会出现。 逻辑如下： 1、当应用程序需要从数据库读取数据时，先检查缓存数据是否命中。 2、如果缓存命中，则查下数据库获取数据，同时将数据写到缓存中并设置过期时间，以便后续读取相同数据会命中缓存，最后再把数据返回给调用者。 3、如果缓存命中，直接...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/myBlog/%E5%85%AD%E3%80%81Redis/6.3%20%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7.html"}],["meta",{"property":"og:site_name","content":"Java笔记"}],["meta",{"property":"og:title","content":"6.3 保证缓存和数据库的一致性"}],["meta",{"property":"og:description","content":"6.3 保证缓存和数据库的一致性 一、只读场景 注意：单独的只读去数据场景是不会出现不一致。只有读和写在一起才会出现。 逻辑如下： 1、当应用程序需要从数据库读取数据时，先检查缓存数据是否命中。 2、如果缓存命中，则查下数据库获取数据，同时将数据写到缓存中并设置过期时间，以便后续读取相同数据会命中缓存，最后再把数据返回给调用者。 3、如果缓存命中，直接..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-18T10:03:31.000Z"}],["meta",{"property":"article:tag","content":"缓存和数据库一致性"}],["meta",{"property":"article:tag","content":"只读场景"}],["meta",{"property":"article:tag","content":"并发读写场景"}],["meta",{"property":"article:published_time","content":"2024-11-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-18T10:03:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"6.3 保证缓存和数据库的一致性\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-18T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-18T10:03:31.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"冉庆\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"一、只读场景","slug":"一、只读场景","link":"#一、只读场景","children":[]},{"level":2,"title":"二、并发读写数据场景","slug":"二、并发读写数据场景","link":"#二、并发读写数据场景","children":[{"level":3,"title":"1、删除缓存重试机制","slug":"_1、删除缓存重试机制","link":"#_1、删除缓存重试机制","children":[]}]}],"git":{"createdTime":1731924211000,"updatedTime":1731924211000,"contributors":[{"name":"ranqing","email":"2516488782@qq.com","commits":1}]},"readingTime":{"minutes":2.17,"words":650},"filePathRelative":"六、Redis/6.3 保证缓存和数据库的一致性.md","localizedDate":"2024年11月18日","excerpt":"\\n<h2>一、只读场景</h2>\\n<p><strong>注意</strong>：单独的只读去数据场景是不会出现不一致。只有读和写在一起才会出现。</p>\\n<p>逻辑如下：</p>\\n<figure><figcaption></figcaption></figure>\\n<p>1、当应用程序需要从数据库读取数据时，先检查缓存数据是否命中。\\n2、如果缓存命中，则查下数据库获取数据，同时将数据写到缓存中并设置过期时间，以便后续读取相同数据会命中缓存，最后再把数据返回给调用者。\\n3、如果缓存命中，直接返回。</p>\\n<h2>二、并发读写数据场景</h2>\\n<p><strong>先操作数据库再操作缓存</strong></p>","autoDesc":true}')}}]);