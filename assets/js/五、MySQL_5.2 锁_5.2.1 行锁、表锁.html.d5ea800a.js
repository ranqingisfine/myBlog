"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2810],{6262:(i,s)=>{s.A=(i,s)=>{const a=i.__vccOpts||i;for(const[i,e]of s)a[i]=e;return a}},7716:(i,s,a)=>{i.exports=a.p+"assets/img/29.58e4df85.jpg"},4616:(i,s,a)=>{a.r(s),a.d(s,{comp:()=>A,data:()=>o});var e=a(641);const l=a.p+"assets/img/23.744b315d.jpg",n=a.p+"assets/img/24.88445fe2.jpg",t=a.p+"assets/img/25.17fa9b4a.jpg",h=a.p+"assets/img/26.b60e9e15.jpg",k=a.p+"assets/img/30.9e413e54.jpg",p=a.p+"assets/img/27.83dd8f0c.jpg",d=a.p+"assets/img/28.e7017ae0.jpg";var r=a(7716);const g={},A=(0,a(6262).A)(g,[["render",function(i,s){return(0,e.uX)(),(0,e.CE)("div",null,s[0]||(s[0]=[(0,e.Fv)('<h1 id="_5-2-1-行锁、表锁" tabindex="-1"><a class="header-anchor" href="#_5-2-1-行锁、表锁"><span>5.2.1 行锁、表锁</span></a></h1><h2 id="一、介绍" tabindex="-1"><a class="header-anchor" href="#一、介绍"><span>一、介绍</span></a></h2><p>首先锁的存在，目的是为了在并发场景下，保持数据的安全、一致。 并发场景有：</p><ul><li><p>读-读 ：此并发场景不需要进行并发控制，也就是不需要加锁。</p></li><li><p>读-写 ：此并发场景需要并发控制，不然就会出现脏读，幻读，不可重复读的问题。</p></li><li><p>写-写 ：此并发场景需要并发控制，不然就会出现更新丢失的问题。</p><p>进行并发控制，常规手段就是加锁，不管是咋java业务代码中，还是mysql数据库本身，都有实现自己的锁，其中mysql的锁有以下几种：</p></li></ul><p><strong>行锁</strong>：锁住表中的一行；比如 update user set name=‘张三’ where id=1；会锁住id=1的那一行数据，其他事务再想更新，就只能等前一个事务释放锁。 <strong>表锁</strong>：锁住整个表，比如update user set name=‘张三’；由于没有加where条件，此更新sql会对整个表进行更新，也就是会锁住整个表。 <strong>间隙锁</strong>：比如事务A执行update user set name=‘张三’ where id &gt;1 and id&lt;4; 假如表中只有id=1、2 两条数据，A事务还没提交，那么此时事务B再次插入一条id=3的数据，理论上是允许的，但是实际上是B只能等A提交，因为事务A执行的是id&gt;1and id&lt;4，范围涵盖了id=3的，也即是把id=3的这个间隙也给锁了，叫做间隙锁。</p><h2 id="二、mvcc和各种锁的关系" tabindex="-1"><a class="header-anchor" href="#二、mvcc和各种锁的关系"><span>二、MVCC和各种锁的关系</span></a></h2><p>既然可以使用行锁、表锁、间隙锁来保证数据操作的安全性，那么还要MVCC的出现是为何呢？ 实际是因为在性能方面还有优化的空间。</p><p>引入多版本之后，<strong>只有写写之间相互阻塞</strong>，其他三种操作都可以MVCC并行，这样大幅度提高了InnoDB的并发度。</p><p>因此，mysql是同时使用了MVCC+行锁、表锁、间隙锁来保证了数据安全，又尽可能大的实现了性能最优化。</p><h2 id="三、准备工作" tabindex="-1"><a class="header-anchor" href="#三、准备工作"><span>三、准备工作</span></a></h2><p><strong>创建表</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">drop</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> table</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> if</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> exists</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> test_innodb_lock;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">CREATE</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> TABLE</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> test_innodb_lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    a </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">INT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">11</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">),</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    b </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">VARCHAR</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">20</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) ENGINE INNODB </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">DEFAULT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> charset </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> utf8;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">insert into</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> test_innodb_lock </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">values</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;a&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">insert into</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> test_innodb_lock </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">values</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;b&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">insert into</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> test_innodb_lock </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">values</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;c&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">insert into</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> test_innodb_lock </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">values</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;d&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">insert into</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> test_innodb_lock </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">values</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;e&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>创建索引</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">create</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> index</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> idx_lock_a</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> on</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> test_innodb_lock(a);</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">create</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> index</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> idx_lock_b</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> on</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> test_innodb_lock(b);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>先将自动提交事务改成手动提交：<code>set autocommit=0;</code></li><li>我们启动两个会话窗口 A 和 B，模拟一个抢到锁，一个没抢到被阻塞住了。</li></ul><h2 id="四、行锁" tabindex="-1"><a class="header-anchor" href="#四、行锁"><span>四、行锁</span></a></h2><p><strong>行锁</strong>：锁住表中的一行；比如 update user set name=‘张三’ where id=1；会锁住id=1的那一行数据，其他事务再想更新，就只能等前一个事务释放锁。</p><h3 id="_1、行锁-写-读" tabindex="-1"><a class="header-anchor" href="#_1、行锁-写-读"><span>1、行锁（写&amp;读）</span></a></h3><ul><li>A 窗口执行</li></ul><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">update</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> test_innodb_lock </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> b</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;a1&#39;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> test_innodb_lock;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>我们可以看到 A 窗口可以看到更新后的结果</p><ul><li>B 窗口执行</li></ul><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> test_innodb_lock;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>我们可以看到 B 窗口不能看到更新后的结果，看到的还是老数据，这是因为 a = 1 的这行记录被 A 窗口执行的 SQL 语句抢到了锁，并且没有执行 commit 提交操作。所以窗口 B 看到的还是老数据。这就是 MySQL 隔离级别中的&quot;<strong>读已提交</strong>&quot;。</p><ul><li>窗口 A 执行 commit 操作</li></ul><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">COMMIT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>窗口 B 查询</li></ul><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> test_innodb_lock;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这个时候我们发现窗口 B 已经读取到最新数据了</p><h3 id="_2、行锁-写-写" tabindex="-1"><a class="header-anchor" href="#_2、行锁-写-写"><span>2、行锁（写&amp;写）</span></a></h3><ul><li>窗口 A 执行更新 a = 1 的记录</li></ul><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">update</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> test_innodb_lock </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> b</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;a2&#39;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这时候并没有 commit 提交，锁是窗口 A 持有。</p><ul><li>窗口 B 也执行更新 a = 1 的记录</li></ul><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">update</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> test_innodb_lock </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> b</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;a3&#39;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>可以看到，窗口 B 一直处于阻塞状态，因为窗口 A 还没有执行 commit，还持有锁。窗口 B 抢不到 a = 1 这行记录的锁，所以一直阻塞等待。</strong></p><ul><li>窗口 A 执行 commit 操作</li></ul><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">COMMIT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>窗口 B 的变化</li></ul><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以看到这个时候窗口 B 已经执行成功了</p><h3 id="_3、行锁分析" tabindex="-1"><a class="header-anchor" href="#_3、行锁分析"><span>3、行锁分析</span></a></h3><ul><li>执行 SQL 分析命令</li></ul><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">show </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">status</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> like</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;innodb_row_lock%&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><figure><img src="'+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>Variable_name 说明 <ul><li>Innodb_row_lock_current_waits：当前正在等待锁定的数量。</li><li>Innodb_row_lock_time：从系统启动到现在锁定的时长。</li><li>Innodb_row_lock_time_avg：每次等待锁所花平均时间。</li><li>Innodb_row_lock_time_max：从系统启动到现在锁等待最长的一次所花的时间。</li><li>Innodb_row_lock_waits：系统启动后到现在总共等待锁的次数。</li></ul></li></ul><h2 id="五、表锁" tabindex="-1"><a class="header-anchor" href="#五、表锁"><span>五、表锁</span></a></h2><p><strong>当索引失效的时候，行锁会升级成表锁</strong>，索引失效的其中一个方法是对索引自动 or 手动的换型。a 字段本身是 integer，我们加上引号，就变成了 String，这个时候索引就会失效了。</p><ul><li>窗口 A 更新 a = 1 的记录</li></ul><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">update</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> test_innodb_lock </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> b</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;a4&#39;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> or</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>窗口 B 更新 a = 3 的记录</li></ul><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">update</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> test_innodb_lock </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> b</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;b1&#39;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这个时候发现，虽然窗口 A 和 B 更新的行不一样，但是窗口 B 还是被阻塞住了，<strong>就是因为窗口 A 的索引失效，导致行锁升级成了表锁，把整个表锁住了，索引窗口 B 被阻塞了</strong>。</p><ul><li>窗口 A 执行 commit 操作</li></ul><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">COMMIT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>窗口 B 的变化</li></ul><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以看到这个时候窗口 B 已经执行成功了</p><h2 id="六、间隙锁" tabindex="-1"><a class="header-anchor" href="#六、间隙锁"><span>六、间隙锁</span></a></h2><h3 id="_1、什么是间隙锁" tabindex="-1"><a class="header-anchor" href="#_1、什么是间隙锁"><span>1、什么是间隙锁</span></a></h3><p>当我们采用范围条件查询数据时，InnoDB 会对这个范围内的数据进行加锁。比如有 id 为：1、3、5、7 的 4 条数据，我们查找 1-7 范围的数据。那么 1-7 都会被加上锁。2、4、6 也在 1-7 的范围中，但是不存在这些数据记录，这些 2、4、6 就被称为间隙。</p><h3 id="_2、间隙锁的危害" tabindex="-1"><a class="header-anchor" href="#_2、间隙锁的危害"><span>2、间隙锁的危害</span></a></h3><p>范围查找时，会把整个范围的数据全部锁定住，即便这个范围内不存在的一些数据，也会被无辜的锁定住，比如我要在 1、3、5、7 中插入 2，这个时候 1-7 都被锁定住了，根本无法插入 2。在某些场景下会对性能产生很大的影响</p><h3 id="_3、间隙锁演示" tabindex="-1"><a class="header-anchor" href="#_3、间隙锁演示"><span>3、间隙锁演示</span></a></h3><p>我们先把字段 a 的值修改成 1、3、5、7、9</p><ul><li>窗口 A 更新 a = 1~7 范围的数据</li></ul><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">update</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> test_innodb_lock </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> b</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;b5&#39;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> and</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">7</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>窗口 B 在 a = 2 的位置插入数据</li></ul><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">insert into</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> test_innodb_lock </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">values</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;b6&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这个时候发现窗口 B 更新 a = 2 的操作一直在等待，因为 1~7 范围的数据被间隙锁，锁住了。只有等窗口 A 执行 commit，窗口 B 的 a = 2 才能更新成功。</p><p>参考：https://blog.csdn.net/csdn_20150804/article/details/119766846</p>',76)]))}]]),o=JSON.parse('{"path":"/%E4%BA%94%E3%80%81MySQL/5.2%20%E9%94%81/5.2.1%20%E8%A1%8C%E9%94%81%E3%80%81%E8%A1%A8%E9%94%81.html","title":"5.2.1 行锁、表锁","lang":"zh-CN","frontmatter":{"\x3c!--cover":"/assets/images/cover2.jpg--\x3e","icon":"pen-to-square","date":"2024-11-14T00:00:00.000Z","category":["MySQL","事务"],"tag":["行锁","表锁"],"star":true,"ticky":true,"description":"5.2.1 行锁、表锁 一、介绍 首先锁的存在，目的是为了在并发场景下，保持数据的安全、一致。 并发场景有： 读-读 ：此并发场景不需要进行并发控制，也就是不需要加锁。 读-写 ：此并发场景需要并发控制，不然就会出现脏读，幻读，不可重复读的问题。 写-写 ：此并发场景需要并发控制，不然就会出现更新丢失的问题。 进行并发控制，常规手段就是加锁，不管是咋j...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/myBlog/%E4%BA%94%E3%80%81MySQL/5.2%20%E9%94%81/5.2.1%20%E8%A1%8C%E9%94%81%E3%80%81%E8%A1%A8%E9%94%81.html"}],["meta",{"property":"og:site_name","content":"Java笔记"}],["meta",{"property":"og:title","content":"5.2.1 行锁、表锁"}],["meta",{"property":"og:description","content":"5.2.1 行锁、表锁 一、介绍 首先锁的存在，目的是为了在并发场景下，保持数据的安全、一致。 并发场景有： 读-读 ：此并发场景不需要进行并发控制，也就是不需要加锁。 读-写 ：此并发场景需要并发控制，不然就会出现脏读，幻读，不可重复读的问题。 写-写 ：此并发场景需要并发控制，不然就会出现更新丢失的问题。 进行并发控制，常规手段就是加锁，不管是咋j..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-15T09:59:14.000Z"}],["meta",{"property":"article:tag","content":"行锁"}],["meta",{"property":"article:tag","content":"表锁"}],["meta",{"property":"article:published_time","content":"2024-11-14T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-15T09:59:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"5.2.1 行锁、表锁\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-14T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-15T09:59:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"冉庆\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"一、介绍","slug":"一、介绍","link":"#一、介绍","children":[]},{"level":2,"title":"二、MVCC和各种锁的关系","slug":"二、mvcc和各种锁的关系","link":"#二、mvcc和各种锁的关系","children":[]},{"level":2,"title":"三、准备工作","slug":"三、准备工作","link":"#三、准备工作","children":[]},{"level":2,"title":"四、行锁","slug":"四、行锁","link":"#四、行锁","children":[{"level":3,"title":"1、行锁（写&读）","slug":"_1、行锁-写-读","link":"#_1、行锁-写-读","children":[]},{"level":3,"title":"2、行锁（写&写）","slug":"_2、行锁-写-写","link":"#_2、行锁-写-写","children":[]},{"level":3,"title":"3、行锁分析","slug":"_3、行锁分析","link":"#_3、行锁分析","children":[]}]},{"level":2,"title":"五、表锁","slug":"五、表锁","link":"#五、表锁","children":[]},{"level":2,"title":"六、间隙锁","slug":"六、间隙锁","link":"#六、间隙锁","children":[{"level":3,"title":"1、什么是间隙锁","slug":"_1、什么是间隙锁","link":"#_1、什么是间隙锁","children":[]},{"level":3,"title":"2、间隙锁的危害","slug":"_2、间隙锁的危害","link":"#_2、间隙锁的危害","children":[]},{"level":3,"title":"3、间隙锁演示","slug":"_3、间隙锁演示","link":"#_3、间隙锁演示","children":[]}]}],"git":{"createdTime":1731570129000,"updatedTime":1731664754000,"contributors":[{"name":"ranqing","email":"2516488782@qq.com","commits":1}]},"readingTime":{"minutes":5.72,"words":1717},"filePathRelative":"五、MySQL/5.2 锁/5.2.1 行锁、表锁.md","localizedDate":"2024年11月14日","excerpt":"\\n<h2>一、介绍</h2>\\n<p>首先锁的存在，目的是为了在并发场景下，保持数据的安全、一致。\\n并发场景有：</p>\\n<ul>\\n<li>\\n<p>读-读 ：此并发场景不需要进行并发控制，也就是不需要加锁。</p>\\n</li>\\n<li>\\n<p>读-写 ：此并发场景需要并发控制，不然就会出现脏读，幻读，不可重复读的问题。</p>\\n</li>\\n<li>\\n<p>写-写 ：此并发场景需要并发控制，不然就会出现更新丢失的问题。</p>\\n<p>进行并发控制，常规手段就是加锁，不管是咋java业务代码中，还是mysql数据库本身，都有实现自己的锁，其中mysql的锁有以下几种：</p>\\n</li>\\n</ul>","autoDesc":true}')}}]);