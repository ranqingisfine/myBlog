"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5218],{6262:(s,i)=>{i.A=(s,i)=>{const a=s.__vccOpts||s;for(const[s,e]of i)a[s]=e;return a}},2029:(s,i,a)=>{a.r(i),a.d(i,{comp:()=>l,data:()=>t});var e=a(641);const n={},l=(0,a(6262).A)(n,[["render",function(s,i){return(0,e.uX)(),(0,e.CE)("div",null,i[0]||(i[0]=[(0,e.Fv)('<h1 id="_6-1-一文了解redis" tabindex="-1"><a class="header-anchor" href="#_6-1-一文了解redis"><span>6.1 一文了解Redis</span></a></h1><h2 id="一、redis使用场景" tabindex="-1"><a class="header-anchor" href="#一、redis使用场景"><span>一、Redis使用场景</span></a></h2><ul><li>缓存：将经常被访问的数据存储在Redis中，减少对数据库的访问压力</li><li>计数器：使用Redis的原子操作，实现高并发场景下的计数功能</li><li>分布式锁：使用Redis的原子操作和过期时间设置，实现分布式锁，确保在分布式系统中的数据一致性。</li><li>简单的发布订阅消息系统：实现消息的异步处理</li></ul><h2 id="二、redis是单线程的" tabindex="-1"><a class="header-anchor" href="#二、redis是单线程的"><span>二、Redis是单线程的</span></a></h2><p>Redis是很快的，官⽅表示，Redis是基于<strong>内存操作</strong>，CPU不是Redis性能瓶颈，Redis的瓶颈是根据机器的<strong>内存和⽹络带宽</strong>，既然可以使⽤单线程来实现，就使⽤单线程了！所有就使⽤了单线程了！</p><p><strong>Redis单线程为什么还这么快？</strong>——redis 是将所有的数据全部放在内存中的，所以说使⽤单线程去操作效率就是最⾼的，多线程（CPU上下⽂会切换：耗时的操作！！！），对于内存系统来说，如果没有上下⽂切换效率就是最⾼的！多次读写都是在⼀个CPU上的，在内存情况下，这个就是最佳的⽅案！</p><ul><li>纯内存操作</li><li>单线程操作，避免了频繁的上下文切换</li><li>采用了非阻塞I/O多路复用机制，参考<a href="https://ranqingisfine.github.io/myBlog/%E4%B8%80%E3%80%81Java%E5%9F%BA%E7%A1%80/1.3%20Java%20IO%E6%A8%A1%E5%9E%8B/1.3.1%20BIO%E3%80%81NIO.html" target="_blank" rel="noopener noreferrer">BIO、NIO文章</a></li></ul><h2 id="三、redis-watch的理解" tabindex="-1"><a class="header-anchor" href="#三、redis-watch的理解"><span>三、Redis Watch的理解</span></a></h2><p><strong>Redis会不会产生ABA问题？</strong></p><p>在 Redis中使用 watch 命令可以决定事务是执行还是回滚。</p><p>一般而言，可以在 multi 命令之前使用 watch 命令监控某些键值对，然后使用 multi 命令开启事务，执行各类对数据结构进行操作的命令，这个时候这些命令就会进入队列。</p><p>当 Redis 使用 exec 命令执行事务的时候，它首先会去比对被 watch 命令所监控的键值对，</p><ul><li>如果没有发生变化，那么它会执行事务队列中的命令，提交事务；</li><li>如果发生变化，那么它不会执行任何事务中的命令，而去事务回滚。</li></ul><p><strong>使用watch成功提交的事务的案例：</strong></p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">127.0.0.1:6379</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">FLUSHDB</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">OK</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">127.0.0.1:6379</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">SET</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key1</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> value1</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">OK</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">127.0.0.1:6379</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">WATCH</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key1</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">OK</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">127.0.0.1:6379</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">MULTI</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">OK</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">127.0.0.1:6379</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">SET</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key2</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> value2</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">QUEUED</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">127.0.0.1:6379</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">EXEC</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) OK</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">127.0.0.1:6379</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>使用watch回滚的事务的案例</strong></p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">127.0.0.1:6379</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">FLUSHDB</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">OK</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">127.0.0.1:6379</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">127.0.0.1:6379</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">SET</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key1</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> value1</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">OK</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">127.0.0.1:6379</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">WATCH</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key1</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">OK</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">127.0.0.1:6379</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">MULTI</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">OK</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">127.0.0.1:6379</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">set</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key2</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> value2</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">QUEUED</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 在这一步暂停下，打开第二个客户端去修改key1的值，然后再exec</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">127.0.0.1:6379</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">exec</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">nil</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">127.0.0.1:6379</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>客户端 1：执行事务，但是事务会先检查在 T2 时刻被监控的 key1 是否被其他命令修改过。因为客户揣 2 修改过，所以它会回滚事务，事实上如果客户端执行的是 set key1 value1 命令，它也会认为 key1 被修改过，然后返回( nil) ，所以是不会产生 ABA 问题的.</p><h2 id="四、redis高并发" tabindex="-1"><a class="header-anchor" href="#四、redis高并发"><span>四、Redis高并发</span></a></h2><p>redis高并发：主从架构，一主多从，一般来说，很多项目其实就足够了，单主用来写入数据，单机几万QPS，多从用来查询数据，多个从实例可以提供每秒10万的QPS。</p>',20)]))}]]),t=JSON.parse('{"path":"/%E5%85%AD%E3%80%81Redis/6.1%20%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3Redis.html","title":"6.1 一文了解Redis","lang":"zh-CN","frontmatter":{"\x3c!--cover":"/assets/images/cover2.jpg--\x3e","icon":"pen-to-square","date":"2024-11-18T00:00:00.000Z","category":["Redis"],"tag":["redis使用场景","redis watch"],"star":true,"ticky":true,"description":"6.1 一文了解Redis 一、Redis使用场景 缓存：将经常被访问的数据存储在Redis中，减少对数据库的访问压力 计数器：使用Redis的原子操作，实现高并发场景下的计数功能 分布式锁：使用Redis的原子操作和过期时间设置，实现分布式锁，确保在分布式系统中的数据一致性。 简单的发布订阅消息系统：实现消息的异步处理 二、Redis是单线程的 Re...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/myBlog/%E5%85%AD%E3%80%81Redis/6.1%20%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3Redis.html"}],["meta",{"property":"og:site_name","content":"Java笔记"}],["meta",{"property":"og:title","content":"6.1 一文了解Redis"}],["meta",{"property":"og:description","content":"6.1 一文了解Redis 一、Redis使用场景 缓存：将经常被访问的数据存储在Redis中，减少对数据库的访问压力 计数器：使用Redis的原子操作，实现高并发场景下的计数功能 分布式锁：使用Redis的原子操作和过期时间设置，实现分布式锁，确保在分布式系统中的数据一致性。 简单的发布订阅消息系统：实现消息的异步处理 二、Redis是单线程的 Re..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-19T12:32:17.000Z"}],["meta",{"property":"article:tag","content":"redis使用场景"}],["meta",{"property":"article:tag","content":"redis watch"}],["meta",{"property":"article:published_time","content":"2024-11-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-19T12:32:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"6.1 一文了解Redis\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-18T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-19T12:32:17.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"冉庆\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"一、Redis使用场景","slug":"一、redis使用场景","link":"#一、redis使用场景","children":[]},{"level":2,"title":"二、Redis是单线程的","slug":"二、redis是单线程的","link":"#二、redis是单线程的","children":[]},{"level":2,"title":"三、Redis Watch的理解","slug":"三、redis-watch的理解","link":"#三、redis-watch的理解","children":[]},{"level":2,"title":"四、Redis高并发","slug":"四、redis高并发","link":"#四、redis高并发","children":[]}],"git":{"createdTime":1731919167000,"updatedTime":1732019537000,"contributors":[{"name":"ranqing","email":"2516488782@qq.com","commits":2}]},"readingTime":{"minutes":2.85,"words":855},"filePathRelative":"六、Redis/6.1 一文了解Redis.md","localizedDate":"2024年11月18日","excerpt":"\\n<h2>一、Redis使用场景</h2>\\n<ul>\\n<li>缓存：将经常被访问的数据存储在Redis中，减少对数据库的访问压力</li>\\n<li>计数器：使用Redis的原子操作，实现高并发场景下的计数功能</li>\\n<li>分布式锁：使用Redis的原子操作和过期时间设置，实现分布式锁，确保在分布式系统中的数据一致性。</li>\\n<li>简单的发布订阅消息系统：实现消息的异步处理</li>\\n</ul>\\n<h2>二、Redis是单线程的</h2>\\n<p>Redis是很快的，官⽅表示，Redis是基于<strong>内存操作</strong>，CPU不是Redis性能瓶颈，Redis的瓶颈是根据机器的<strong>内存和⽹络带宽</strong>，既然可以使⽤单线程来实现，就使⽤单线程了！所有就使⽤了单线程了！</p>","autoDesc":true}')}}]);