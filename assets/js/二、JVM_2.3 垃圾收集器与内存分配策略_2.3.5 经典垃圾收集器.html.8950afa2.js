"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2039],{66262:(l,e)=>{e.A=(l,e)=>{const i=l.__vccOpts||l;for(const[l,a]of e)i[l]=a;return i}},48735:(l,e,i)=>{i.r(e),i.d(e,{comp:()=>n,data:()=>p});var a=i(20641);const r=i.p+"assets/img/5.09bcf1e6.png",t={},n=(0,i(66262).A)(t,[["render",function(l,e){return(0,a.uX)(),(0,a.CE)("div",null,e[0]||(e[0]=[(0,a.Fv)('<h1 id="_2-3-5-经典垃圾收集器" tabindex="-1"><a class="header-anchor" href="#_2-3-5-经典垃圾收集器"><span>2.3.5 经典垃圾收集器</span></a></h1><p>各款经典垃圾收集器对应关系如下：</p><figure><img src="'+r+'" alt="垃圾收集器" tabindex="0" loading="lazy"><figcaption>垃圾收集器</figcaption></figure><h2 id="一、serial" tabindex="-1"><a class="header-anchor" href="#一、serial"><span>一、Serial</span></a></h2><hr><p>和Serial Old搭配使用</p><p><strong>概念</strong>：</p><ul><li>是一个单线程工作的收集器，意味着不仅仅只会使用一个处理器去完成收集工作，更重要是必须暂停所有线程（Stop The Word），直到它收集结束。</li><li>新生代采取标记-复制算法暂停所有用户线程</li></ul><p><strong>优点</strong>：</p><ul><li><p>HotSpot虚拟机客户端模式下默认的新生代收集器，内存消耗最小</p></li><li><p>适用于单核处理器或处理器核心数较少的环境，没有线程交互开销，效率更高</p></li></ul><h2 id="二、parnew" tabindex="-1"><a class="header-anchor" href="#二、parnew"><span>二、ParNew</span></a></h2><hr><p>和Serial Old和CMS搭配使用</p><p><strong>概念</strong>：</p><ul><li>是Serial收集器的多线程版本并行版本，除了多线程垃圾回收外，多了一些控制参数</li><li>新生代采取标记-复制算法暂停所有用户线程</li></ul><p>单核处理器还是Serial更适合，多核处理器ParNew更适合且会默认开启与核心数相等的线程。</p><h2 id="三、parallel-scavenge" tabindex="-1"><a class="header-anchor" href="#三、parallel-scavenge"><span>三、Parallel Scavenge</span></a></h2><hr><p><strong>概念</strong>：</p><ul><li>多线程收集器，和ParNew类似</li><li>新生代采取标记-复制算法暂停所有用户线程</li></ul><p><strong>和ParNew区别</strong>：</p><ul><li>其它收集器关注停顿时间，而Parallel Scavenge关注可控制的吞吐量</li><li>停顿时间越短越适合用户交互或需要保证服务响应的程序，而高吞吐量适合不需要太多交互的计算分析任务</li><li>Parallel Scavenge可设置自适应吞吐量调节策略，把内存调优任务交给虚拟机完成，这是区别于ParNew的重要特性</li></ul><h2 id="四、serial-old" tabindex="-1"><a class="header-anchor" href="#四、serial-old"><span>四、Serial Old</span></a></h2><hr><p><strong>概念</strong>：</p><ul><li>Serial Old是Serial收集器的老年代版本，是单线程收集器</li><li>使用标记—整理算法</li></ul><h2 id="五、parallel-old" tabindex="-1"><a class="header-anchor" href="#五、parallel-old"><span>五、Parallel Old</span></a></h2><hr><p><strong>概念</strong>：</p><ul><li>Parallel Old是Parallel Scavenge的老年代版本，多线程并发收集</li><li>使用标记—整理算法</li></ul><p><strong>吞吐量优先的搭配：Parallel Scavenge+Parallel Old</strong></p><h2 id="六、cms" tabindex="-1"><a class="header-anchor" href="#六、cms"><span>六、CMS</span></a></h2><hr><p><strong>最短停顿时间的搭配：ParNew + CMS</strong></p><p>CBCB</p><p>初始标记</p><ul><li>STW，暂停所有工作线程</li><li>然后标记出GC Roots能直接可达的对象</li><li>一旦标记完，就恢复工作线程继续执行</li><li>这阶段耗时短</li></ul><p>并发标记</p><ul><li>从上个阶段标记出来的对象，开始遍历整个老年代，标记出所有可达的对象</li><li>耗时长，但不需要STW，用户线程与垃圾收集线程一起执行</li><li>三色标记</li></ul><p>重新标记</p><ul><li>上个阶段标记的对象可能有误差（三色标记），需要进行修正</li><li>需要STW，但时间不长</li><li>增量更新</li></ul><p>并发清除</p><ul><li>删除垃圾对象</li><li>由于不需要移动对象，这阶段可以和用户线程一起执行，不需要STW</li></ul><p>注意：</p><ul><li>并发标记和并发清理是和用户线程同时进行的，如果有对象进入老年代而空间又不够，就会用Serial Old做一次垃圾收集全局STW</li><li>标记清除会产生内存碎片，可通过参数设置多少次GC后做整理，默认0，表示每次都需要整理</li><li>并发清理产生的新垃圾“浮动垃圾”，只能等下一次GC时清理</li></ul><h2 id="七、g1" tabindex="-1"><a class="header-anchor" href="#七、g1"><span>七、G1</span></a></h2><p>JDK9发布后，G1宣告取代了Parallel Scavenge + Parallel Old组合，成为服务端模式下的默认垃圾收集器，而CMS沦落为不再使用</p><p>G1目标：用户可设定允许收集停顿时间</p><p><strong>概念</strong>：</p><ul><li>G1基于Region的堆内存布局，仍然遵循分代收集理论，把连续的java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理。</li><li>Region有一类特殊的Humongous（巨大的）区域，专门用来存储大对象。G1认为只要大小超过了Region容量一半的对象即可判定为大对象</li><li>Region时单次回收的最小单元</li></ul><p><strong>一些问题</strong>：</p><ol><li><p>HotSpot使用卡表实现的记忆集解决跨代引用问题，G1的跨Region引用对象如何解决 G1的记忆集本质上是一种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号。这种双向的卡表结构比原来的卡表更复杂。</p></li><li><p>并发标记阶段如何保证收集线程与用户线程不干扰的运行</p><p>G1通过原始快照实现</p></li><li><p>怎样建立起可靠的停顿预测模型 G1记录每个Region的回收耗时等统计信息，然后通过这些信息预测哪些Region组成的回收集可以在不超过期望停顿时间的约束下获得最高的效益</p></li></ol><p><strong>G1收集器运作过程</strong></p><p>初始标记（同CMS的初始标记阶段）</p><ul><li>STW，暂停所有工作线程</li><li>然后标记出GC Roots能直接可达的对象</li><li>一旦标记完，就恢复工作线程继续执行</li><li>这阶段耗时短</li></ul><p>并发标记（同CMS并发标记）</p><ul><li>从上个阶段标记出来的对象，开始遍历整个老年代，标记出所有可达的对象</li><li>耗时长，但不需要STW，用户线程与垃圾收集线程一起执行</li><li>三色标记</li></ul><p>最终标记（同CMS重新标记）</p><ul><li>上个阶段标记的对象可能有误差（三色标记），需要进行修正</li><li>需要STW，但时间不长</li><li>增量更新</li></ul><p>筛选回收（类似CMS的并发清除阶段）</p><ul><li>需要STW，来清除对象</li><li>可指定GC停顿时间，默认200ms，所以可能并不会回收掉所有垃圾对象</li><li>采用复制算法，不会产生碎片</li></ul><h2 id="八、场景" tabindex="-1"><a class="header-anchor" href="#八、场景"><span>八、场景</span></a></h2><ol><li>单核处理器场景、JVM客户端模式，用Serial + Serial Old</li><li>程序后台运算而不需要太多交互、吞吐量优先，用Parallel Scavenge + Parallel Old</li><li>以最短回收停顿时间为目标、互联网网站、基于浏览器的B/S系统服务端，用ParNew + CMS</li><li>JDK9发布后，G1宣告取代了Parallel Scavenge + Parallel Old组合，成为服务端模式下的默认垃圾收集器，而CMS沦落为不再使用</li></ol>',63)]))}]]),p=JSON.parse('{"path":"/%E4%BA%8C%E3%80%81JVM/2.3%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/2.3.5%20%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.html","title":"2.3.5 经典垃圾收集器","lang":"zh-CN","frontmatter":{"\x3c!--cover":"/assets/images/cover2.jpg--\x3e","icon":"pen-to-square","date":"2024-12-07T00:00:00.000Z","category":["JVM","垃圾收集器与内存分配策略"],"tag":["经典垃圾收集器"],"star":true,"ticky":true,"description":"2.3.5 经典垃圾收集器 各款经典垃圾收集器对应关系如下： 垃圾收集器垃圾收集器 一、Serial 和Serial Old搭配使用 概念： 是一个单线程工作的收集器，意味着不仅仅只会使用一个处理器去完成收集工作，更重要是必须暂停所有线程（Stop The Word），直到它收集结束。 新生代采取标记-复制算法暂停所有用户线程 优点： HotSpot虚...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/myBlog/%E4%BA%8C%E3%80%81JVM/2.3%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/2.3.5%20%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.html"}],["meta",{"property":"og:site_name","content":"Java笔记"}],["meta",{"property":"og:title","content":"2.3.5 经典垃圾收集器"}],["meta",{"property":"og:description","content":"2.3.5 经典垃圾收集器 各款经典垃圾收集器对应关系如下： 垃圾收集器垃圾收集器 一、Serial 和Serial Old搭配使用 概念： 是一个单线程工作的收集器，意味着不仅仅只会使用一个处理器去完成收集工作，更重要是必须暂停所有线程（Stop The Word），直到它收集结束。 新生代采取标记-复制算法暂停所有用户线程 优点： HotSpot虚..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-07T03:11:12.000Z"}],["meta",{"property":"article:tag","content":"经典垃圾收集器"}],["meta",{"property":"article:published_time","content":"2024-12-07T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-07T03:11:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"2.3.5 经典垃圾收集器\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-12-07T00:00:00.000Z\\",\\"dateModified\\":\\"2024-12-07T03:11:12.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"冉庆\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"一、Serial","slug":"一、serial","link":"#一、serial","children":[]},{"level":2,"title":"二、ParNew","slug":"二、parnew","link":"#二、parnew","children":[]},{"level":2,"title":"三、Parallel Scavenge","slug":"三、parallel-scavenge","link":"#三、parallel-scavenge","children":[]},{"level":2,"title":"四、Serial Old","slug":"四、serial-old","link":"#四、serial-old","children":[]},{"level":2,"title":"五、Parallel Old","slug":"五、parallel-old","link":"#五、parallel-old","children":[]},{"level":2,"title":"六、CMS","slug":"六、cms","link":"#六、cms","children":[]},{"level":2,"title":"七、G1","slug":"七、g1","link":"#七、g1","children":[]},{"level":2,"title":"八、场景","slug":"八、场景","link":"#八、场景","children":[]}],"git":{"createdTime":1733540796000,"updatedTime":1733541072000,"contributors":[{"name":"ranqing","email":"2516488782@qq.com","commits":2}]},"readingTime":{"minutes":5.45,"words":1635},"filePathRelative":"二、JVM/2.3 垃圾收集器与内存分配策略/2.3.5 经典垃圾收集器.md","localizedDate":"2024年12月7日","excerpt":"\\n<p>各款经典垃圾收集器对应关系如下：</p>\\n<figure><figcaption>垃圾收集器</figcaption></figure>\\n<h2>一、Serial</h2>\\n<hr>\\n<p>和Serial Old搭配使用</p>\\n<p><strong>概念</strong>：</p>\\n<ul>\\n<li>是一个单线程工作的收集器，意味着不仅仅只会使用一个处理器去完成收集工作，更重要是必须暂停所有线程（Stop The Word），直到它收集结束。</li>\\n<li>新生代采取标记-复制算法暂停所有用户线程</li>\\n</ul>\\n<p><strong>优点</strong>：</p>\\n<ul>\\n<li>\\n<p>HotSpot虚拟机客户端模式下默认的新生代收集器，内存消耗最小</p>\\n</li>\\n<li>\\n<p>适用于单核处理器或处理器核心数较少的环境，没有线程交互开销，效率更高</p>\\n</li>\\n</ul>","autoDesc":true}')}}]);