"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[7648],{66262:(t,s)=>{s.A=(t,s)=>{const e=t.__vccOpts||t;for(const[t,i]of s)e[t]=i;return e}},80545:(t,s,e)=>{e.r(s),e.d(s,{comp:()=>l,data:()=>n});var i=e(20641);const a={},l=(0,e(66262).A)(a,[["render",function(t,s){return(0,i.uX)(),(0,i.CE)("div",null,s[0]||(s[0]=[(0,i.Fv)('<h1 id="_2-5-3-双亲委派模型" tabindex="-1"><a class="header-anchor" href="#_2-5-3-双亲委派模型"><span>2.5.3 双亲委派模型</span></a></h1><p>（本文介绍JDK8以及之前的三层类加载器）</p><p><strong>类加载器</strong>：将类的字节码文件加载到内存中，并将其转化为JVM能够识别处理的运行时数据结构。</p><p><strong>比较两个类相等</strong>：只有在这两个类是由同一个类加载器的前提下才有意义。</p><p><strong>双亲委派模型作用</strong>：</p><ul><li>防止加载同一个class文件，通过委托询问上级是否已加载过class，如果加载过了，就不需要重新加载，保证了数据的安全性</li><li>保证核心class不被篡改。通过委托的方式，即使被篡改也不会被加载，即使被加载也不会是同一个class对象</li></ul><p><strong>启动类加载器（Bootstrap Class Loader）</strong>（引导类加载器）</p><ul><li>负责加载存放在<code>&lt;JAVA_HOME&gt;\\lib</code>目录，而且是虚拟机能够按照文件名识别的（如rt.jar、tools.jar）的类库加载到虚拟机内存中</li><li>启动类加载器无法被Java程序直接引用，因为启动类加载器由于是用 C++ 实现的，没有对应的 Java 类表示</li></ul><p><strong>扩展类加载器（ExtClassLoader）</strong></p><ul><li>负责加载存放在<code>&lt;JAVA_HOME&gt;\\lib\\ext</code>目录中的类库</li><li>扩展类加载器可以在Java程序中直接使用</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//获取的是应用程序类加载器，而它的父加载器就是扩展类加载器。</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ClassLoader</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> extensionClassLoader </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> ClassLoader</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getSystemClassLoader</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getParent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>应用程序类加载器（AppClassLoader）</strong></p><ul><li>负责加载用户路径（ClassPath）上所有类库</li><li>如果应用程序中没有定义自己的类加载器，一般情况下这就是程序中默认的类加载器</li></ul><p>双亲委派模型的代码实现参考P283</p><p><strong>双亲委派模型工作过程</strong>：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传递到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。</p>',15)]))}]]),n=JSON.parse('{"path":"/%E4%BA%8C%E3%80%81JVM/2.5%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/2.5.3%20%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.html","title":"2.5.3 双亲委派模型","lang":"zh-CN","frontmatter":{"\x3c!--cover":"/assets/images/cover2.jpg--\x3e","icon":"pen-to-square","date":"2024-12-09T00:00:00.000Z","category":["JVM","虚拟机类加载机制"],"tag":["双亲委派模型"],"star":true,"ticky":true,"description":"2.5.3 双亲委派模型 （本文介绍JDK8以及之前的三层类加载器） 类加载器：将类的字节码文件加载到内存中，并将其转化为JVM能够识别处理的运行时数据结构。 比较两个类相等：只有在这两个类是由同一个类加载器的前提下才有意义。 双亲委派模型作用： 防止加载同一个class文件，通过委托询问上级是否已加载过class，如果加载过了，就不需要重新加载，保证...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/myBlog/%E4%BA%8C%E3%80%81JVM/2.5%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/2.5.3%20%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.html"}],["meta",{"property":"og:site_name","content":"Java笔记"}],["meta",{"property":"og:title","content":"2.5.3 双亲委派模型"}],["meta",{"property":"og:description","content":"2.5.3 双亲委派模型 （本文介绍JDK8以及之前的三层类加载器） 类加载器：将类的字节码文件加载到内存中，并将其转化为JVM能够识别处理的运行时数据结构。 比较两个类相等：只有在这两个类是由同一个类加载器的前提下才有意义。 双亲委派模型作用： 防止加载同一个class文件，通过委托询问上级是否已加载过class，如果加载过了，就不需要重新加载，保证..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-09T06:53:31.000Z"}],["meta",{"property":"article:tag","content":"双亲委派模型"}],["meta",{"property":"article:published_time","content":"2024-12-09T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-09T06:53:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"2.5.3 双亲委派模型\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-12-09T00:00:00.000Z\\",\\"dateModified\\":\\"2024-12-09T06:53:31.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"冉庆\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[],"git":{"createdTime":1733727211000,"updatedTime":1733727211000,"contributors":[{"name":"ranqing","email":"2516488782@qq.com","commits":1}]},"readingTime":{"minutes":2.02,"words":605},"filePathRelative":"二、JVM/2.5 虚拟机类加载机制/2.5.3 双亲委派模型.md","localizedDate":"2024年12月9日","excerpt":"\\n<p>（本文介绍JDK8以及之前的三层类加载器）</p>\\n<p><strong>类加载器</strong>：将类的字节码文件加载到内存中，并将其转化为JVM能够识别处理的运行时数据结构。</p>\\n<p><strong>比较两个类相等</strong>：只有在这两个类是由同一个类加载器的前提下才有意义。</p>\\n<p><strong>双亲委派模型作用</strong>：</p>\\n<ul>\\n<li>防止加载同一个class文件，通过委托询问上级是否已加载过class，如果加载过了，就不需要重新加载，保证了数据的安全性</li>\\n<li>保证核心class不被篡改。通过委托的方式，即使被篡改也不会被加载，即使被加载也不会是同一个class对象</li>\\n</ul>","autoDesc":true}')}}]);