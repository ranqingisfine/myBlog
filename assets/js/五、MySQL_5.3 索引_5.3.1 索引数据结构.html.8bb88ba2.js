"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[947],{66262:(e,i)=>{i.A=(e,i)=>{const t=e.__vccOpts||e;for(const[e,a]of i)t[e]=a;return t}},75716:(e,i,t)=>{t.r(i),t.d(i,{comp:()=>u,data:()=>m});var a=t(20641);const l=t.p+"assets/img/31.cfbf107f.png",n=t.p+"assets/img/32.e475da66.png",r=t.p+"assets/img/33.e30314bb.png",p=t.p+"assets/img/34.02e4d7de.png",s=t.p+"assets/img/35.8983884e.png",g=t.p+"assets/img/51.fe0a239b.png",o=t.p+"assets/img/52.415a3103.png",c=t.p+"assets/img/53.4691eb87.png",h=t.p+"assets/img/59.04e84c10.png",d=t.p+"assets/img/60.407606b0.png",f={},u=(0,t(66262).A)(f,[["render",function(e,i){return(0,a.uX)(),(0,a.CE)("div",null,i[0]||(i[0]=[(0,a.Fv)('<h1 id="_5-3-1-索引数据结构" tabindex="-1"><a class="header-anchor" href="#_5-3-1-索引数据结构"><span>5.3.1 索引数据结构</span></a></h1><p><strong>索引</strong>是帮助MySQL高效获取数据的排好序的数据结构</p><p>索引数据结构</p><ul><li>二叉树</li><li>红黑树</li><li>Hash表</li><li>B-Tree</li><li>B+Tree</li></ul><p>上面的数据结构有什么缺点？为什么MySQL底层采用B+树呢？</p><h2 id="一、二叉树" tabindex="-1"><a class="header-anchor" href="#一、二叉树"><span>一、二叉树</span></a></h2><p>如果索引是二叉树数据结构，它有个严重问题，比如Col1自增的数据列存储到二叉树的数据结构中，自增的数据列存储到二叉树中会变成一个链表，那跟全表查找一样了</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="二、红黑树" tabindex="-1"><a class="header-anchor" href="#二、红黑树"><span>二、红黑树</span></a></h2><p>红黑树又叫平衡二叉树，HashMap底层就是用的红黑树</p><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>跟二叉树对比，平衡二叉树查找元素6，只用查找3次！效率更高。</p><p>但是红黑树高度不可控。mysql底层没有用红黑树数据结构，如果数据上百万，那么树的高度会特别高，查找的次数会更多，磁盘io也会很大。所有尽量要树的高度越小，那么查找次数越少。</p><h2 id="三、b-tree" tabindex="-1"><a class="header-anchor" href="#三、b-tree"><span>三、B-Tree</span></a></h2><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>高度跟二叉树相同的情况下存储的数更多。</p><h2 id="四、b-tree" tabindex="-1"><a class="header-anchor" href="#四、b-tree"><span>四、B+Tree</span></a></h2><p>mysql底层在B树的基础上优化为B+树</p><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>B+树解决了平衡二叉树当数据越多，高度不可控的问题。</p><p>B树和B+树的区别</p><ul><li><p>B树的每个结点都存储了key和data，B+树的data存储在叶子节点上。节点不存储data，这样一个节点就可以存储更多的key。可以使得树更矮，所以IO操作次数更少。</p></li><li><p>树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</p></li></ul><h2 id="五、b-tree的查找" tabindex="-1"><a class="header-anchor" href="#五、b-tree的查找"><span>五、B+Tree的查找</span></a></h2><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>将一个节点加载到内存就是一次io操作。版本高的mysql事先就会把非叶子结点加载到内存里面，效率更高，最终只需要一次磁盘查找就能找到元素。所以千万级别的表走索引也很快.</p><p><strong>上面说“B+树高度越小，效率更高”，那如果h=1是不是更好？</strong>——不是的，高度为1的B+树相当于链表，而且全是叶子节点和data。1000w的表查找某个字段就把所有的节点加载到内存，不合适。一般来说会把冗余索引加载到内存，带有data的叶子节点不好加载到内存。</p><p><strong>当单表的数据量达到 1000W 或 100G 以后</strong>，要求分库分表了。</p><h2 id="六、hash" tabindex="-1"><a class="header-anchor" href="#六、hash"><span>六、Hash</span></a></h2><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>用来干嘛的？</p><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>为什么B+树能够支持范围查找？</strong></p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="七、索引使用介绍" tabindex="-1"><a class="header-anchor" href="#七、索引使用介绍"><span>七、索引使用介绍</span></a></h2><p><strong>索引的创建</strong></p><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>哪些情况需要创建索引</strong></p><ul><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段应该创建索引（银行系统的银行卡号，电信系统的手机号...）</li><li>查询中与其它表关联的字段，外键关系建立索引</li><li>频繁更新的字段不适合创建索引，因为每次更新不单单是更新了记录，还会更新索引，加重IO负担(不光更新数据，还会更新B+树)</li><li>where条件里用不到的字段不创建索引</li><li>单键/组合索引的选择问题，who？（在高并发下倾向创建组合索引）</li><li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度</li><li>查询中统计或者分组字段</li></ul><p><strong>哪些情况不要创建索引</strong></p><ul><li><p>表记录太少</p></li><li><p>经常增删改的表</p><ul><li>Why：提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。</li></ul></li><li><p>数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</p></li></ul><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',41)]))}]]),m=JSON.parse('{"path":"/%E4%BA%94%E3%80%81MySQL/5.3%20%E7%B4%A2%E5%BC%95/5.3.1%20%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html","title":"5.3.1 索引数据结构","lang":"zh-CN","frontmatter":{"\x3c!--cover":"/assets/images/cover2.jpg--\x3e","icon":"pen-to-square","date":"2024-11-14T00:00:00.000Z","category":["索引"],"tag":["索引数据结构","B+Tree"],"star":true,"ticky":true,"description":"5.3.1 索引数据结构 索引是帮助MySQL高效获取数据的排好序的数据结构 索引数据结构 二叉树 红黑树 Hash表 B-Tree B+Tree 上面的数据结构有什么缺点？为什么MySQL底层采用B+树呢？ 一、二叉树 如果索引是二叉树数据结构，它有个严重问题，比如Col1自增的数据列存储到二叉树的数据结构中，自增的数据列存储到二叉树中会变成一个链表...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/myBlog/%E4%BA%94%E3%80%81MySQL/5.3%20%E7%B4%A2%E5%BC%95/5.3.1%20%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"}],["meta",{"property":"og:site_name","content":"Java笔记"}],["meta",{"property":"og:title","content":"5.3.1 索引数据结构"}],["meta",{"property":"og:description","content":"5.3.1 索引数据结构 索引是帮助MySQL高效获取数据的排好序的数据结构 索引数据结构 二叉树 红黑树 Hash表 B-Tree B+Tree 上面的数据结构有什么缺点？为什么MySQL底层采用B+树呢？ 一、二叉树 如果索引是二叉树数据结构，它有个严重问题，比如Col1自增的数据列存储到二叉树的数据结构中，自增的数据列存储到二叉树中会变成一个链表..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-16T02:33:48.000Z"}],["meta",{"property":"article:tag","content":"索引数据结构"}],["meta",{"property":"article:tag","content":"B+Tree"}],["meta",{"property":"article:published_time","content":"2024-11-14T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-16T02:33:48.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"5.3.1 索引数据结构\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-14T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-16T02:33:48.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"冉庆\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"一、二叉树","slug":"一、二叉树","link":"#一、二叉树","children":[]},{"level":2,"title":"二、红黑树","slug":"二、红黑树","link":"#二、红黑树","children":[]},{"level":2,"title":"三、B-Tree","slug":"三、b-tree","link":"#三、b-tree","children":[]},{"level":2,"title":"四、B+Tree","slug":"四、b-tree","link":"#四、b-tree","children":[]},{"level":2,"title":"五、B+Tree的查找","slug":"五、b-tree的查找","link":"#五、b-tree的查找","children":[]},{"level":2,"title":"六、Hash","slug":"六、hash","link":"#六、hash","children":[]},{"level":2,"title":"七、索引使用介绍","slug":"七、索引使用介绍","link":"#七、索引使用介绍","children":[]}],"git":{"createdTime":1731576678000,"updatedTime":1731724428000,"contributors":[{"name":"ranqing","email":"2516488782@qq.com","commits":3}]},"readingTime":{"minutes":3.75,"words":1124},"filePathRelative":"五、MySQL/5.3 索引/5.3.1 索引数据结构.md","localizedDate":"2024年11月14日","excerpt":"\\n<p><strong>索引</strong>是帮助MySQL高效获取数据的排好序的数据结构</p>\\n<p>索引数据结构</p>\\n<ul>\\n<li>二叉树</li>\\n<li>红黑树</li>\\n<li>Hash表</li>\\n<li>B-Tree</li>\\n<li>B+Tree</li>\\n</ul>\\n<p>上面的数据结构有什么缺点？为什么MySQL底层采用B+树呢？</p>\\n<h2>一、二叉树</h2>\\n<p>如果索引是二叉树数据结构，它有个严重问题，比如Col1自增的数据列存储到二叉树的数据结构中，自增的数据列存储到二叉树中会变成一个链表，那跟全表查找一样了</p>\\n<figure><figcaption></figcaption></figure>","autoDesc":true}')}}]);