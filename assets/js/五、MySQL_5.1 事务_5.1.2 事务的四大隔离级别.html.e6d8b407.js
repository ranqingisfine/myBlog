"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2314],{6262:(e,t)=>{t.A=(e,t)=>{const a=e.__vccOpts||e;for(const[e,n]of t)a[e]=n;return a}},4284:(e,t,a)=>{a.r(t),a.d(t,{comp:()=>o,data:()=>l});var n=a(641);const i={},o=(0,a(6262).A)(i,[["render",function(e,t){return(0,n.uX)(),(0,n.CE)("div",null,t[0]||(t[0]=[(0,n.Fv)('<h1 id="_5-1-2-事务的四大隔离级别" tabindex="-1"><a class="header-anchor" href="#_5-1-2-事务的四大隔离级别"><span>5.1.2 事务的四大隔离级别</span></a></h1><p>既然并发事务存在<strong>脏读、不可重复、幻读</strong>等问题，InnoDB实现了哪几种事务的隔离级别应对呢？</p><ul><li>读未提交（Read Uncommitted）</li><li>读已提交（Read Committed）</li><li>可重复读（Repeatable Read）（mysql默认隔离级别）</li><li>串行化（Serializable）</li></ul><h2 id="一、读未提交" tabindex="-1"><a class="header-anchor" href="#一、读未提交"><span>一、读未提交</span></a></h2><p>我们去数据库给它设置<strong>读未提交</strong>隔离级别，实践一下吧~</p>',5)]))}]]),l=JSON.parse('{"path":"/%E4%BA%94%E3%80%81MySQL/5.1%20%E4%BA%8B%E5%8A%A1/5.1.2%20%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.html","title":"5.1.2 事务的四大隔离级别","lang":"zh-CN","frontmatter":{"description":"5.1.2 事务的四大隔离级别 既然并发事务存在脏读、不可重复、幻读等问题，InnoDB实现了哪几种事务的隔离级别应对呢？ 读未提交（Read Uncommitted） 读已提交（Read Committed） 可重复读（Repeatable Read）（mysql默认隔离级别） 串行化（Serializable） 一、读未提交 我们去数据库给它设置读...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/myBlog/%E4%BA%94%E3%80%81MySQL/5.1%20%E4%BA%8B%E5%8A%A1/5.1.2%20%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.html"}],["meta",{"property":"og:site_name","content":"Java笔记"}],["meta",{"property":"og:title","content":"5.1.2 事务的四大隔离级别"}],["meta",{"property":"og:description","content":"5.1.2 事务的四大隔离级别 既然并发事务存在脏读、不可重复、幻读等问题，InnoDB实现了哪几种事务的隔离级别应对呢？ 读未提交（Read Uncommitted） 读已提交（Read Committed） 可重复读（Repeatable Read）（mysql默认隔离级别） 串行化（Serializable） 一、读未提交 我们去数据库给它设置读..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-12T01:58:30.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-12T01:58:30.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"5.1.2 事务的四大隔离级别\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-11-12T01:58:30.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"冉庆\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"一、读未提交","slug":"一、读未提交","link":"#一、读未提交","children":[]}],"git":{"createdTime":1731323279000,"updatedTime":1731376710000,"contributors":[{"name":"ranqing","email":"2516488782@qq.com","commits":2}]},"readingTime":{"minutes":0.34,"words":103},"filePathRelative":"五、MySQL/5.1 事务/5.1.2 事务的四大隔离级别.md","localizedDate":"2024年11月11日","excerpt":"\\n<p>既然并发事务存在<strong>脏读、不可重复、幻读</strong>等问题，InnoDB实现了哪几种事务的隔离级别应对呢？</p>\\n<ul>\\n<li>读未提交（Read Uncommitted）</li>\\n<li>读已提交（Read Committed）</li>\\n<li>可重复读（Repeatable Read）（mysql默认隔离级别）</li>\\n<li>串行化（Serializable）</li>\\n</ul>\\n<h2>一、读未提交</h2>\\n<p>我们去数据库给它设置<strong>读未提交</strong>隔离级别，实践一下吧~</p>\\n","autoDesc":true}')}}]);