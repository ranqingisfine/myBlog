"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[947],{6262:(e,t)=>{t.A=(e,t)=>{const a=e.__vccOpts||e;for(const[e,i]of t)a[e]=i;return a}},3089:(e,t,a)=>{a.r(t),a.d(t,{comp:()=>c,data:()=>g});var i=a(641);const r=a.p+"assets/img/31.cfbf107f.png",n=a.p+"assets/img/32.e475da66.png",p=a.p+"assets/img/33.e30314bb.png",l=a.p+"assets/img/34.02e4d7de.png",o=a.p+"assets/img/35.8983884e.png",s={},c=(0,a(6262).A)(s,[["render",function(e,t){return(0,i.uX)(),(0,i.CE)("div",null,t[0]||(t[0]=[(0,i.Fv)('<h1 id="_5-3-1-索引数据结构" tabindex="-1"><a class="header-anchor" href="#_5-3-1-索引数据结构"><span>5.3.1 索引数据结构</span></a></h1><p><strong>索引</strong>是帮助MySQL高效获取数据的排好序的数据结构</p><p>索引数据结构</p><ul><li>二叉树</li><li>红黑树</li><li>Hash表</li><li>B-Tree</li><li>B+Tree</li></ul><p>上面的数据结构有什么缺点？为什么MySQL底层采用B+树呢？</p><h2 id="一、二叉树" tabindex="-1"><a class="header-anchor" href="#一、二叉树"><span>一、二叉树</span></a></h2><p>如果索引是二叉树数据结构，它有个严重问题，比如Col1自增的数据列存储到二叉树的数据结构中，自增的数据列存储到二叉树中会变成一个链表，那跟全表查找一样了</p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="二、红黑树" tabindex="-1"><a class="header-anchor" href="#二、红黑树"><span>二、红黑树</span></a></h2><p>红黑树又叫平衡二叉树，HashMap底层就是用的红黑树</p><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>跟二叉树对比，平衡二叉树查找元素6，只用查找3次！效率更高。</p><p>但是红黑树高度不可控。mysql底层没有用红黑树数据结构，如果数据上百万，那么树的高度会特别高，查找的次数会更多，磁盘io也会很大。所有尽量要树的高度越小，那么查找次数越少。</p><h2 id="三、b-tree" tabindex="-1"><a class="header-anchor" href="#三、b-tree"><span>三、B-Tree</span></a></h2><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>高度跟二叉树相同的情况下存储的数更多。</p><h2 id="四、b-tree" tabindex="-1"><a class="header-anchor" href="#四、b-tree"><span>四、B+Tree</span></a></h2><p>mysql底层在B树的基础上优化为B+树</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>B+树解决了平衡二叉树当数据越多，高度不可控的问题。</p><p>B树和B+树的区别</p><ul><li><p>B树的每个结点都存储了key和data，B+树的data存储在叶子节点上。节点不存储data，这样一个节点就可以存储更多的key。可以使得树更矮，所以IO操作次数更少。</p></li><li><p>树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</p></li></ul><h2 id="五、b-tree的查找" tabindex="-1"><a class="header-anchor" href="#五、b-tree的查找"><span>五、B+Tree的查找</span></a></h2><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>将一个节点加载到内存就是一次io操作。版本高的mysql事先就会把非叶子结点加载到内存里面，效率更高，最终只需要一次磁盘查找就能找到元素。所以千万级别的表走索引也很快.</p><p><strong>上面说“B+树高度越小，效率更高”，那如果h=1是不是更好？</strong>——不是的，高度为1的B+树相当于链表，而且全是叶子节点和data。1000w的表查找某个字段就把所有的节点加载到内存，不合适。一般来说会把冗余索引加载到内存，带有data的叶子节点不好加载到内存。</p><p><strong>当单表的数据量达到 1000W 或 100G 以后</strong>，要求分库分表了。</p>',27)]))}]]),g=JSON.parse('{"path":"/%E4%BA%94%E3%80%81MySQL/5.3%20%E7%B4%A2%E5%BC%95/5.3.1%20%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html","title":"5.3.1 索引数据结构","lang":"zh-CN","frontmatter":{"\x3c!--cover":"/assets/images/cover2.jpg--\x3e","icon":"pen-to-square","date":"2024-11-14T00:00:00.000Z","category":["索引"],"tag":["索引数据结构","B+Tree"],"star":true,"ticky":true,"description":"5.3.1 索引数据结构 索引是帮助MySQL高效获取数据的排好序的数据结构 索引数据结构 二叉树 红黑树 Hash表 B-Tree B+Tree 上面的数据结构有什么缺点？为什么MySQL底层采用B+树呢？ 一、二叉树 如果索引是二叉树数据结构，它有个严重问题，比如Col1自增的数据列存储到二叉树的数据结构中，自增的数据列存储到二叉树中会变成一个链表...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/myBlog/%E4%BA%94%E3%80%81MySQL/5.3%20%E7%B4%A2%E5%BC%95/5.3.1%20%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"}],["meta",{"property":"og:site_name","content":"Java笔记"}],["meta",{"property":"og:title","content":"5.3.1 索引数据结构"}],["meta",{"property":"og:description","content":"5.3.1 索引数据结构 索引是帮助MySQL高效获取数据的排好序的数据结构 索引数据结构 二叉树 红黑树 Hash表 B-Tree B+Tree 上面的数据结构有什么缺点？为什么MySQL底层采用B+树呢？ 一、二叉树 如果索引是二叉树数据结构，它有个严重问题，比如Col1自增的数据列存储到二叉树的数据结构中，自增的数据列存储到二叉树中会变成一个链表..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-15T07:41:42.000Z"}],["meta",{"property":"article:tag","content":"索引数据结构"}],["meta",{"property":"article:tag","content":"B+Tree"}],["meta",{"property":"article:published_time","content":"2024-11-14T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-15T07:41:42.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"5.3.1 索引数据结构\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-14T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-15T07:41:42.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"冉庆\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"一、二叉树","slug":"一、二叉树","link":"#一、二叉树","children":[]},{"level":2,"title":"二、红黑树","slug":"二、红黑树","link":"#二、红黑树","children":[]},{"level":2,"title":"三、B-Tree","slug":"三、b-tree","link":"#三、b-tree","children":[]},{"level":2,"title":"四、B+Tree","slug":"四、b-tree","link":"#四、b-tree","children":[]},{"level":2,"title":"五、B+Tree的查找","slug":"五、b-tree的查找","link":"#五、b-tree的查找","children":[]}],"git":{"createdTime":1731576678000,"updatedTime":1731656502000,"contributors":[{"name":"ranqing","email":"2516488782@qq.com","commits":1}]},"readingTime":{"minutes":2.44,"words":732},"filePathRelative":"五、MySQL/5.3 索引/5.3.1 索引数据结构.md","localizedDate":"2024年11月14日","excerpt":"\\n<p><strong>索引</strong>是帮助MySQL高效获取数据的排好序的数据结构</p>\\n<p>索引数据结构</p>\\n<ul>\\n<li>二叉树</li>\\n<li>红黑树</li>\\n<li>Hash表</li>\\n<li>B-Tree</li>\\n<li>B+Tree</li>\\n</ul>\\n<p>上面的数据结构有什么缺点？为什么MySQL底层采用B+树呢？</p>\\n<h2>一、二叉树</h2>\\n<p>如果索引是二叉树数据结构，它有个严重问题，比如Col1自增的数据列存储到二叉树的数据结构中，自增的数据列存储到二叉树中会变成一个链表，那跟全表查找一样了</p>\\n<figure><figcaption></figcaption></figure>","autoDesc":true}')}}]);