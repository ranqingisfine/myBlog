"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[775],{66262:(e,t)=>{t.A=(e,t)=>{const i=e.__vccOpts||e;for(const[e,a]of t)i[e]=a;return i}},33610:(e,t,i)=>{i.r(t),i.d(t,{comp:()=>r,data:()=>l});var a=i(20641);const n={},r=(0,i(66262).A)(n,[["render",function(e,t){return(0,a.uX)(),(0,a.CE)("div",null,t[0]||(t[0]=[(0,a.Fv)('<h1 id="_4-5-4-读写锁" tabindex="-1"><a class="header-anchor" href="#_4-5-4-读写锁"><span>4.5.4 读写锁</span></a></h1><h2 id="一、概念" tabindex="-1"><a class="header-anchor" href="#一、概念"><span>一、概念</span></a></h2><p>先代入两个问题：1、只在写操作加互斥锁不行吗，为什么非要读写锁。2、什么场景会用到读写锁。</p><p>读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其它写线程均被阻塞。特点是<strong>读读不互斥、读写互斥、写写互斥</strong>。</p><p>读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升，它的优点有：</p><ul><li>提高了程序执行性能：多个读锁可以同时执行，相比于普通锁在任何情况下都要排队执行来说，读写锁提高了程序的执行性能</li><li>避免读到临时数据：读锁和写锁是互斥排队执行的，这样可以保证了读取操作不会读到写了一半的临时数据。</li></ul><p><strong>特性</strong>：</p><ul><li>非公平锁（默认），也可选择公平锁</li><li>重进入</li><li>锁降级：获取写锁--&gt;获取读锁--&gt;释放写锁，即写锁能够降级成读锁</li></ul><p><strong>读写锁的使用</strong></p><p>在 Java 语言中，读写锁是使用 ReentrantReadWriteLock 类来实现的，其中：</p><ul><li>ReentrantReadWriteLock.ReadLock 表示读锁，它提供了 lock 方法进行加锁、unlock 方法进行解锁。</li><li>ReentrantReadWriteLock.WriteLock 表示写锁，它提供了 lock 方法进行加锁、unlock 方法进行解锁。</li></ul><p>在分布式场景中，读写锁建议采用Redisson来实现，具体请参考下面的Redisson文章</p><h2 id="二、场景" tabindex="-1"><a class="header-anchor" href="#二、场景"><span>二、场景</span></a></h2><p>读写锁有以下<strong>特点</strong>：</p><ul><li>允许多个线程在没有写入时同时读取，可以提高读取效率</li><li>当存在写入情况时，只允许一个线程写入，其他线程进入排队等待</li><li>适合读多写少的场景</li></ul><p><strong>读写锁适合多读少写的业务场景</strong>，对于同一个数据，有大量线程读取，但仅有少数线程修改，使用<code>ReadWriteLock</code>可以显著的提升程序并发执行效率。例如，一个论坛的帖子，浏览可以看做读取操作，是非常频繁的，而回复可以看做写入操作，它是不频繁的.</p><p>比如在业务中碰到下面的这个情况：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>xx平台评论功能使用了读写锁实现，锁对象是文章编号。写操作的时候需要加锁，因为写业务需要往数据库表里面新增一条评论，然后总览里该文章和总文章的评论数+1，如果不加锁，评论数统计会不准确。为什么要用读写锁，1 因为读读不需要加锁，提高性能；2 读写和写写加锁，防止出现脏读和幻读比如两次读到情况不一致的情况，比如读区发生在写操作的中间，会出现读取到了评论，但是评论数未加1。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>看到这里，就不难回答前面提的两个问题了。</p>',19)]))}]]),l=JSON.parse('{"path":"/%E5%9B%9B%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/4.5%20Java%E4%B8%AD%E7%9A%84%E9%94%81/4.5.4%20%E8%AF%BB%E5%86%99%E9%94%81.html","title":"4.5.4 读写锁","lang":"zh-CN","frontmatter":{"\x3c!--cover":"/assets/images/cover2.jpg--\x3e","icon":"pen-to-square","date":"2024-11-27T00:00:00.000Z","category":["并发编程","Java中的锁"],"tag":["读写锁"],"star":true,"ticky":true,"description":"4.5.4 读写锁 一、概念 先代入两个问题：1、只在写操作加互斥锁不行吗，为什么非要读写锁。2、什么场景会用到读写锁。 读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其它写线程均被阻塞。特点是读读不互斥、读写互斥、写写互斥。 读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/myBlog/%E5%9B%9B%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/4.5%20Java%E4%B8%AD%E7%9A%84%E9%94%81/4.5.4%20%E8%AF%BB%E5%86%99%E9%94%81.html"}],["meta",{"property":"og:site_name","content":"Java笔记"}],["meta",{"property":"og:title","content":"4.5.4 读写锁"}],["meta",{"property":"og:description","content":"4.5.4 读写锁 一、概念 先代入两个问题：1、只在写操作加互斥锁不行吗，为什么非要读写锁。2、什么场景会用到读写锁。 读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其它写线程均被阻塞。特点是读读不互斥、读写互斥、写写互斥。 读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-27T14:03:01.000Z"}],["meta",{"property":"article:tag","content":"读写锁"}],["meta",{"property":"article:published_time","content":"2024-11-27T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-27T14:03:01.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"4.5.4 读写锁\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-27T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-27T14:03:01.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"冉庆\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"一、概念","slug":"一、概念","link":"#一、概念","children":[]},{"level":2,"title":"二、场景","slug":"二、场景","link":"#二、场景","children":[]}],"git":{"createdTime":1732009797000,"updatedTime":1732716181000,"contributors":[{"name":"ranqing","email":"2516488782@qq.com","commits":3}]},"readingTime":{"minutes":2.64,"words":793},"filePathRelative":"四、并发编程/4.5 Java中的锁/4.5.4 读写锁.md","localizedDate":"2024年11月27日","excerpt":"\\n<h2>一、概念</h2>\\n<p>先代入两个问题：1、只在写操作加互斥锁不行吗，为什么非要读写锁。2、什么场景会用到读写锁。</p>\\n<p>读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其它写线程均被阻塞。特点是<strong>读读不互斥、读写互斥、写写互斥</strong>。</p>\\n<p>读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升，它的优点有：</p>\\n<ul>\\n<li>提高了程序执行性能：多个读锁可以同时执行，相比于普通锁在任何情况下都要排队执行来说，读写锁提高了程序的执行性能</li>\\n<li>避免读到临时数据：读锁和写锁是互斥排队执行的，这样可以保证了读取操作不会读到写了一半的临时数据。</li>\\n</ul>","autoDesc":true}')}}]);