---
<!--cover: /assets/images/cover2.jpg-->
icon: pen-to-square
date: 2024-12-09
category:
  - JVM
  - 虚拟机类加载机制
tag:
  - 双亲委派模型
star: true
ticky: true
---
# 2.5.3 双亲委派模型

（本文介绍JDK8以及之前的三层类加载器）

**类加载器**：将类的字节码文件加载到内存中，并将其转化为JVM能够识别处理的运行时数据结构。

**比较两个类相等**：只有在这两个类是由同一个类加载器的前提下才有意义。

**双亲委派模型作用**：

- 防止加载同一个class文件，通过委托询问上级是否已加载过class，如果加载过了，就不需要重新加载，保证了数据的安全性
- 保证核心class不被篡改。通过委托的方式，即使被篡改也不会被加载，即使被加载也不会是同一个class对象

**启动类加载器（Bootstrap Class Loader）**（引导类加载器）

- 负责加载存放在`<JAVA_HOME>\lib`目录，而且是虚拟机能够按照文件名识别的（如rt.jar、tools.jar）的类库加载到虚拟机内存中
- 启动类加载器无法被Java程序直接引用，因为启动类加载器由于是用 C++ 实现的，没有对应的 Java 类表示

**扩展类加载器（ExtClassLoader）**

- 负责加载存放在`<JAVA_HOME>\lib\ext`目录中的类库
- 扩展类加载器可以在Java程序中直接使用

```java
//获取的是应用程序类加载器，而它的父加载器就是扩展类加载器。
ClassLoader extensionClassLoader = ClassLoader.getSystemClassLoader().getParent();
```

**应用程序类加载器（AppClassLoader）**

- 负责加载用户路径（ClassPath）上所有类库
- 如果应用程序中没有定义自己的类加载器，一般情况下这就是程序中默认的类加载器

双亲委派模型的代码实现参考P283

**双亲委派模型工作过程**：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传递到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。



















