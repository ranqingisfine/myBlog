---
<!--cover: /assets/images/cover2.jpg-->
icon: pen-to-square
date: 2024-12-08
category:
  - JVM
  - 虚拟机类加载机制
tag:
  - 类加载的过程
star: true
ticky: true
---
# 2.5.2 类加载的过程

此文说的类型，指的是“类和接口”

**类加载的过程**：加载	验证	准备	解析	初始化

## 一、加载

---

加载其实可以用一句话来概括，然后对这句话进行解读

**加载**：读一个class文件，将其转化为某种静态数据结构存储在方法区中，并在堆中生成一个便于用户调用的java.lang.Class类型的对象过程。

解读：

- 读一个class文件，没有指定从哪里获取，如何获取，所以就特么很灵活，比如从网络中获取、数据库中获取、加密文件获取等
- 加载阶段是开发人员可控性最强的阶段，即可以用内置的引导类加载器完成，又可以用户自定义类加载器完成
- 方法区里就是存放类信息，可前面的内容贯通起来了
- 在堆中生成一个便于用户调用的java.lang.Class对象，这个对象作为程序访问方法区中的类型数据结构的外部接口。（对象.getClass()获取class对象，然后根据对象获取类的成员变量和方法，具体参考[反射](https://ranqingisfine.github.io/myBlog/%E4%B8%80%E3%80%81Java%E5%9F%BA%E7%A1%80/1.4%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/1.4.2%20%E5%8F%8D%E5%B0%84.html)）

加载阶段和连接阶段是交叉进行，加载阶段尚未完成，连接阶段可能已经开始了，这两个阶段的开始时间仍然保持着固定的先后顺序。

## 二、验证

---

为什么要验证？避免Java虚拟机被恶意代码攻击。

验证阶段会完成4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。

**文件格式验证**：验证字节流是否符合Class文件格式的规范。比如验证是否以魔数开头等。

**元数据验证**：对字节码描述的信息进行分析，确保符合《Java语言规范》要求。

**字节码验证**：确定程序语义是合法的、符合逻辑的。

**符号引用验证**：确保符号引用转化为直接引用（解析阶段）能正常执行。

## 三、准备

---

**准备阶段**：正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段。

解读：

- 内存分配在哪里？JDK8后类变量随着Class对象被分配在堆里
- 准备阶段仅包括类变量，不包括实例变量（实例变量在对象实例化时随着对象分配在堆中）
- 通常情况初始值指的是零值，比如`public static int value=123`准备阶段后初始值是0，而不是123，value赋值123要等类的初始化阶段才执行
- 特殊情况静态不可变，比如`public static final int value=123`，虚拟机准备阶段会给value赋值为123

## 四、解析

---

**解析阶段**：Java虚拟机将常量池内的符号引用替换为直接引用的过程。（结合P49对象的创建过程）

解读：当一个Java类A被编译成Class文件后，A中引用了B，那么在编译阶段，A是不知道B有没有被编译的，此时B页一定未加载，所以A肯定不知道B的实际地址。此时在A的Class文件中，将使用一个字符串S来代表B的地址，S就是符号引用。

在运行时，如果A发生了类加载，到了解析阶段会发现B还未被加载，那么会触发B的类加载，将B加载到虚拟机中，此时A中B的符号引用将被替换成B的实际地址，这被称为直接引用。

解析阶段分为：

- 类或接口的解析
- 字段解析
- 方法解析

## 五、初始化

---

类的初始化是类加载过程的最后一个步骤，初始化阶段Java虚拟机才真正开始执行类中编写的Java程序代码。

初始化阶段就是执行类构造器`<clinit>()`方法的过程，`<clinit>()`并不是程序猿在Java代码中直接编写的方法，而是javac编译器的自动生成物。比如前面讲的准备阶段类变量被赋0值，而在初始化阶段，就可以给变量赋值123。

- 简单理解下`<clinit>()`：由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的**顺序**决定的，例如：

```java
public class Clinit {
    static {
        i=0;
    }
    static  int i=1;

    public static void main(String[] args) {
        System.out.println(i);//输出i=1
    }
}
```

- 显示调用父类构造但是器`<clinit>()`不需要，Java虚拟机会保证子类的`<clinit>()`执行前，父类的`<clinit>()`方法已经执行完毕。意味着父类的静态语句块要优先于子类的变量赋值操作，例如：

```java
static class Parent{
  	public static int A=1;
  	static{
      	A=2;
    }
}
static class Sub extends Parent{
  	public static int B=A;
}
public static void main(String[] args){
  	System.out.println(Sub.B);//输出是2
}
```

- `<clinit>()`对于类和接口不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，编译器可以不为这个类生成`<clinit>()`
- 接口中不能有静态语句块，但是有变量的初始化赋值，所以还是有`<clinit>()`的，但和类不一样的是，执行接口的`<clinit>()`不需要先执行父接口的`<clinit>()`，此外，接口的实现类在初始化时也不会执行接口的`<clinit>()`
- 确保一个类的`<clinit>()`在多线程环境中能被正确地加锁同步。如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的`<clinit>()`，其它线程都需要阻塞等待，直到活动线程`<clinit>()`执行完毕













































