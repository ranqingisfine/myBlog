---
<!--cover: /assets/images/cover2.jpg-->
icon: pen-to-square
date: 2024-12-07
category:
  - JVM
  - 垃圾收集器与内存分配策略
tag:
  - 经典垃圾收集器
star: true
ticky: true
---
# 2.3.5 经典垃圾收集器

各款经典垃圾收集器对应关系如下：

<table>
	<tr>
		<td><b>年轻代垃圾收集器</b></td>
		<td><b>老年代垃圾收集器</b></td>
	<tr>
  <tr>
		<td>Serial</b></td>
		<td>Serial Old</b></td>
	<tr>
  <tr>
		<td>ParNew</b></td>
		<td>Serial Old，CMS</b></td>
	<tr>
  <tr>
		<td>Parallel Scavenge</b></td>
		<td>Serial Old，Parallel Old</b></td>
	<tr>
	<tr>
		<td colspan="2">G1</td>
	<tr>
</table>



## 一、Serial

---

和Serial Old搭配使用

**概念**：

- 是一个单线程工作的收集器，意味着不仅仅只会使用一个处理器去完成收集工作，更重要是必须暂停所有线程（Stop The Word），直到它收集结束。
- 新生代采取标记-复制算法暂停所有用户线程

**优点**：

- HotSpot虚拟机客户端模式下默认的新生代收集器，内存消耗最小

- 适用于单核处理器或处理器核心数较少的环境，没有线程交互开销，效率更高

  

## 二、ParNew

---

和Serial Old和CMS搭配使用

**概念**：

- 是Serial收集器的多线程版本并行版本，除了多线程垃圾回收外，多了一些控制参数
- 新生代采取标记-复制算法暂停所有用户线程

单核处理器还是Serial更适合，多核处理器ParNew更适合且会默认开启与核心数相等的线程。

## 三、Parallel Scavenge

---

**概念**：

- 多线程收集器，和ParNew类似
- 新生代采取标记-复制算法暂停所有用户线程

**和ParNew区别**：

- 其它收集器关注停顿时间，而Parallel Scavenge关注可控制的吞吐量
- 停顿时间越短越适合用户交互或需要保证服务响应的程序，而高吞吐量适合不需要太多交互的计算分析任务
- Parallel Scavenge可设置自适应吞吐量调节策略，把内存调优任务交给虚拟机完成，这是区别于ParNew的重要特性

## 四、Serial Old

---

**概念**：

- Serial Old是Serial收集器的老年代版本，是单线程收集器
- 使用标记—整理算法

## 五、Parallel Old

---

**概念**：

- Parallel Old是Parallel Scavenge的老年代版本，多线程并发收集
- 使用标记—整理算法

**吞吐量优先的搭配：Parallel Scavenge+Parallel Old**

## 六、CMS

---

**最短停顿时间的搭配：ParNew + CMS**

CBCB

初始标记

- STW，暂停所有工作线程
- 然后标记出GC Roots能直接可达的对象
- 一旦标记完，就恢复工作线程继续执行
- 这阶段耗时短

并发标记

- 从上个阶段标记出来的对象，开始遍历整个老年代，标记出所有可达的对象
- 耗时长，但不需要STW，用户线程与垃圾收集线程一起执行
- 三色标记

重新标记

- 上个阶段标记的对象可能有误差（三色标记），需要进行修正
- 需要STW，但时间不长
- 增量更新

并发清除

- 删除垃圾对象
- 由于不需要移动对象，这阶段可以和用户线程一起执行，不需要STW

注意：

- 并发标记和并发清理是和用户线程同时进行的，如果有对象进入老年代而空间又不够，就会用Serial Old做一次垃圾收集全局STW
- 标记清除会产生内存碎片，可通过参数设置多少次GC后做整理，默认0，表示每次都需要整理
- 并发清理产生的新垃圾“浮动垃圾”，只能等下一次GC时清理

## 七、G1

JDK9发布后，G1宣告取代了Parallel Scavenge + Parallel Old组合，成为服务端模式下的默认垃圾收集器，而CMS沦落为不再使用

G1目标：用户可设定允许收集停顿时间

**概念**：

- G1基于Region的堆内存布局，仍然遵循分代收集理论，把连续的java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理。
- Region有一类特殊的Humongous（巨大的）区域，专门用来存储大对象。G1认为只要大小超过了Region容量一半的对象即可判定为大对象
- Region时单次回收的最小单元

**一些问题**：

1. HotSpot使用卡表实现的记忆集解决跨代引用问题，G1的跨Region引用对象如何解决
   G1的记忆集本质上是一种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号。这种双向的卡表结构比原来的卡表更复杂。

2. 并发标记阶段如何保证收集线程与用户线程不干扰的运行

   G1通过原始快照实现

3. 怎样建立起可靠的停顿预测模型
   G1记录每个Region的回收耗时等统计信息，然后通过这些信息预测哪些Region组成的回收集可以在不超过期望停顿时间的约束下获得最高的效益

**G1收集器运作过程**

初始标记（同CMS的初始标记阶段）

- STW，暂停所有工作线程
- 然后标记出GC Roots能直接可达的对象
- 一旦标记完，就恢复工作线程继续执行
- 这阶段耗时短

并发标记（同CMS并发标记）

- 从上个阶段标记出来的对象，开始遍历整个老年代，标记出所有可达的对象
- 耗时长，但不需要STW，用户线程与垃圾收集线程一起执行
- 三色标记

最终标记（同CMS重新标记）

- 上个阶段标记的对象可能有误差（三色标记），需要进行修正
- 需要STW，但时间不长
- 增量更新

筛选回收（类似CMS的并发清除阶段）

- 需要STW，来清除对象
- 可指定GC停顿时间，默认200ms，所以可能并不会回收掉所有垃圾对象
- 采用复制算法，不会产生碎片



## 八、场景

1. 单核处理器场景、JVM客户端模式，用Serial + Serial Old
2. 程序后台运算而不需要太多交互、吞吐量优先，用Parallel Scavenge + Parallel Old
3. 以最短回收停顿时间为目标、互联网网站、基于浏览器的B/S系统服务端，用ParNew + CMS
4. JDK9发布后，G1宣告取代了Parallel Scavenge + Parallel Old组合，成为服务端模式下的默认垃圾收集器，而CMS沦落为不再使用

























































