---
<!--cover: /assets/images/cover2.jpg-->
icon: pen-to-square
date: 2024-11-10
category:
  - 线程安全的实现方法
tag:
  - 互斥同步
  - 非阻塞同步
  - 无同步方案
star: true
ticky: true
---
# 2.9.2 线程安全的实现方法

## 一、互斥同步（阻塞同步）

互斥同步是最常见的并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一时刻只被一条线程使用。互斥是一种手段，可以理解为互斥是因，同步是果。

synchronized和ReentrantLock是互斥同步的实现，可参考[synchronized关键字的理解](https://ranqingisfine.github.io/myBlog/%E4%B8%80%E3%80%81Java%E5%9F%BA%E7%A1%80/1.2%20%E5%85%B3%E9%94%AE%E5%AD%97/1.2.2%20synchronized%E5%85%B3%E9%94%AE%E5%AD%97.html)文章和[Reentrant重入锁](https://ranqingisfine.github.io/myBlog/%E5%9B%9B%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/4.5%20Java%E4%B8%AD%E7%9A%84%E9%94%81/4.5.3%20ReentrantLock%E9%87%8D%E5%85%A5%E9%94%81.html)文章。

## 二、非阻塞同步

互斥同步面临的主要问题是进行线程阻塞和唤醒所带来的性能开销，因此这种同步也被称为阻塞同步。互斥同步是一种悲观的并发策略

**悲观锁**：无论共享的数据是否真的会出现竞争，它都会进行加锁，这将会导致用户态到核心态转换，维护锁计数器和检查是否有被阻塞的线程需要被唤醒等开销。

**乐观锁**：不管风险，先进行操作，如果没有其它线程争用共享数据，那操作就直接成果了；如果共享数据的确被争用，产生了冲突，那再进行其它的补偿措施，最常见的补偿措施就是不断地重试，直到出现没有竞争的共享数据为止。这种乐观并发策略的实现不再需要把线程阻塞挂起，因此这种同步操作被称为**非阻塞同步**。

**为什么使用乐观并发策略需要硬件指令集的发展？**——因为必须要求操作和冲突检测这两个步骤具备原子性，如果用互斥同步来保证就完全失去意义了，所以只能靠硬件来实现这件事情，硬件保证某些从语义上看起来需要多次操作的行为可以只通过一条处理器指令就能完成。常用的有：

```
测试并设置（Test-and-Set）
获取并增加（Fetch-and-Increment）
交换（Swap）
比较并交换（Compare-and-Swap，简称CAS）
```

非阻塞同步——乐观锁参考[Java实现原子操作-循环CAS](https://ranqingisfine.github.io/myBlog/%E5%9B%9B%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/4.2%20Java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/4.2.3%20Java%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C-%E5%BE%AA%E7%8E%AFCAS.html)文章。

## 三、无同步方案

保证线程安全，也并非一定进行阻塞或非阻塞同步，同步与线程安全两者没有必然联系。如果能让一个方法本来就不涉及共享数据，那它自然就不需要任何同步措施去保证其正确性。因为有一些代码天生就是线程安全的。

有下面两类

- 可重入代码。指可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归），而控制权返回后，原来的程序不会出现任何错误，对结果也不会有所影响。它的特征是不依赖全局变量、存储在堆上的数据和公用的系统资源，用到的状态量都是参数中传入，不调用非可重入的方法等。
- 线程本地存储。如ThreadLocal等。
