# 2.9.2 线程安全的实现方法

## 一、互斥同步（阻塞同步）

互斥同步是最常见的并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一时刻只被一条线程使用。互斥是一种手段，可以理解为互斥是因，同步是果。

synchronized和ReentrantLock是互斥同步的实现，可参考[synchronized关键字的理解](https://ranqingisfine.github.io/myBlog/%E4%B8%80%E3%80%81Java%E5%9F%BA%E7%A1%80/1.2%20%E5%85%B3%E9%94%AE%E5%AD%97/1.2.2%20synchronized%E5%85%B3%E9%94%AE%E5%AD%97.html)文章和[Reentrant重入锁](https://ranqingisfine.github.io/myBlog/%E5%9B%9B%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/4.5%20Java%E4%B8%AD%E7%9A%84%E9%94%81/4.5.3%20ReentrantLock%E9%87%8D%E5%85%A5%E9%94%81.html)文章。

## 二、非阻塞同步

互斥同步面临的主要问题是进行线程阻塞和唤醒所带来的性能开销，因此这种同步也被称为阻塞同步。互斥同步是一种悲观的并发策略

**悲观锁**：无论共享的数据是否真的会出现竞争，它都会进行加锁，这将会导致用户态到核心态转换，维护锁计数器和检查是否有被阻塞的线程需要被唤醒等开销。

**乐观锁**：不管风险，先进行操作，如果没有其它线程争用共享数据，那操作就直接成果了；如果共享数据的确被争用，产生了冲突，那再进行其它的补偿措施，最常见的补偿措施就是不断地重试，直到出现没有竞争的共享数据为止。这种乐观并发策略的实现不再需要把线程阻塞挂起，因此这种同步操作被称为**非阻塞同步**。

**为什么使用乐观并发策略需要硬件指令集的发展？**——因为必须要求操作和冲突检测这两个步骤具备原子性，如果用互斥同步来保证就完全失去意义了，所以只能靠硬件来实现这件事情，硬件保证某些从语义上看起来需要多次操作的行为可以只通过一条处理器指令就能完成。常用的有：

```
测试并设置（Test-and-Set）
获取并增加（Fetch-and-Increment）
交换（Swap）
比较并交换（Compare-and-Swap，简称CAS）
```

