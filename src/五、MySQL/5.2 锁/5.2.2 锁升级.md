---
<!--cover: /assets/images/cover2.jpg-->
icon: pen-to-square
date: 2024-11-15
category:
  - MySQL
  - 锁
tag:
  - 锁升级
  - 事务
star: true
ticky: true
---
# 5.2.2 锁升级

本文讨论InnoDB引擎在什么情况下，行锁会升级成表锁。

## 一、update行锁升级成表锁场景

有表如下，id是索引，name是非索引：

```
id		name
1			张三
2			李四
```

- A窗口

```sql
begin;--开启事务
update employees set age=18 where name='张三'

```

- B窗口

```sql
begin;--开启事务
-- 和事物A不是同一条数据
update employees set age=18 where id=2
```

这时候看到B窗口一直处于阻塞的状态。

**在更新的时候，条件没有指定为索引，会导致行锁升级为表锁**，造成性能下降。

```
因为更新首先要拿到更新的那条数据，在找数据时候如果是非索引字段，会进行全表扫描，为了保证原子性，会将整张表锁起来。所以事务B会被阻塞。
```

---

所以只需要将事务A的条件改造为索引的列，就可以解决这个问题

- A窗口

```sql
begin;--开启事务
update employees set age=18 where id=1
```

- B窗口

```sql
begin;--开启事务
-- 和事物A不是同一条数据
update employees set age=18 where id=2
```

事务A和B互不影响。

总结锁升级的场景：

- where条件没有索引
- where条件索引失效

## 二、select for update

就不演示了，直接说结果：**如果select查询条件中使用到了索引有数据，就锁行，没数据就锁表；查询条件中没有使用到索引，就锁表**。

注意：

1. FOR UPDATE仅适用于`InnoDB`，且必须在`事务处理模块(BEGIN/COMMIT)`中才能生效。
2. 要测试锁定的状况，可以利用MySQL的Command Mode(命令模式) ，开两个视窗来做测试。
3. Myisam 只支持表级锁，InnerDB支持行级锁 添加了(行级锁/表级锁)锁的数据不能被其它事务再锁定，也不被其它事务修改。是表级锁时，不管是否查询到记录，都会锁定表。

### 1、减库存案例

假设有A、B两个用户同时各购买一件 id=1 的商品，用户A获取到的库存量为 1000，用户B获取到的库存量也为 1000，用户A完成购买后修改该商品的库存量为 999，用户B完成购买后修改该商品的库存量为 999，此时库存量数据产生了不一致。

#### 1.1 悲观锁的实现方式

要使用悲观锁，必须关闭MySQL数据库的自动提交属性。因为MySQL默认使用autocommit模式，也就是说，当执行一个更新操作后，MySQL会立刻将结果进行提交。(sql语句：set autocommit=0)。

```sql
//开始事务
begin;
//查询出商品库存信息
select quantity from items where id=1 for update;
//修改商品库存为999
update items set quantity=999 where id =1;
//提交事务
commit;
```

以上，对id=1对记录修改钱，先通过for update的方式进行加锁，然后再进行修改。这就是典型的悲观策略。

如果以上修改库存的代码发生并发，同一时间只有一个线程可以开启事务并获得id=1的锁，其它的事务必须等本次事务提交之后才能执行。这样可以保证当前的数据不会被其它事务修改。

注意行锁不要升级成了表锁。

#### 1.2 乐观锁的实现方式

使用乐观锁就不需要借助数据库的锁机制了。乐观锁的概念中其实已经阐述了它的具体实现细节。主要就是两个步骤：冲突检测和数据更新。

　　其实现方式有一种比较典型的就是CAS(Compare and Swap)。CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。

　　比如前面的扣减库存问题，通过乐观锁可以实现如下：

```sql
//查询出商品库存信息，quantity=1000
select quantity from items where id=1;
//修改商品库存为999
update items set quantity=999 where id=1 and quantity=1000;
```

以上，在更新之前，先查询一下库存表中当前库存数(quantity)，然后在做update的时候，以库存数作为一个修改条件。当提交更新的时候，判断数据库表对应记录的当前库存数与第一次取出来的库存数进行比对，如果数据库表当前库存数与第一次取出来的库存数相等，则予以更新，否则认为是过期数据。

　　以上更新语句存在一个比较重要的问题，即传说中的**ABA问题**。比如说一个线程one从数据库中取出库存数1000，这时候另一个线程two也从数据库中取出库存数1000，并且two进行了一些操作变成了999，然后two又将库存数变成1000，这时候线程one进行CAS操作发现数据库中仍然是1000，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。

**有一个比较好的办法可以解决ABA问题，那就是通过一个单独的可以顺序递增的version字段**

乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。

　　除了version以外，还可以使用时间戳，因为时间戳天然具有顺序递增性。

　　以上SQL其实还是有一定的问题的，就是一旦遇上高并发的时候，就只有一个线程可以修改成功，那么就会存在大量的失败。对于像淘宝这样的电商网站，高并发是常有的事，总让用户感知到失败显然是不合理的。所以，还是要想办法减少乐观锁的粒度的。有一条比较好的建议，可以减小乐观锁力度，最大程度的提升吞吐率，提高并发能力！如下：

```sql
update item set quantity=quantity-1 where id=1 and quantity-1>0
```

以上SQL语句中，如果用户下单数为1，则通过quantity - 1 > 0的方式进行乐观锁控制。以上update语句，在执行过程中，会在一次原子操作中自己查询一遍quantity的值，并将其扣减掉1。

随着互联网三高架构（高并发、高性能、高可用）的提出，悲观锁已经越来越少的被应用到生产环境中了，尤其是并发量比较大的业务场景



