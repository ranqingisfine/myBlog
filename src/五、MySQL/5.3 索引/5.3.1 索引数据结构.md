---
<!--cover: /assets/images/cover2.jpg-->
icon: pen-to-square
date: 2024-11-14
category:
  - 索引
tag:
  - 索引数据结构
  - B+Tree
star: true
ticky: true
---
# 5.3.1 索引数据结构

**索引**是帮助MySQL高效获取数据的排好序的数据结构

索引数据结构

- 二叉树
- 红黑树
- Hash表
- B-Tree
- B+Tree

上面的数据结构有什么缺点？为什么MySQL底层采用B+树呢？

## 一、二叉树

如果索引是二叉树数据结构，它有个严重问题，比如Col1自增的数据列存储到二叉树的数据结构中，自增的数据列存储到二叉树中会变成一个链表，那跟全表查找一样了

![](../pic/31.png)

## 二、红黑树

红黑树又叫平衡二叉树，HashMap底层就是用的红黑树

![](../pic/32.png)

跟二叉树对比，平衡二叉树查找元素6，只用查找3次！效率更高。

但是红黑树高度不可控。mysql底层没有用红黑树数据结构，如果数据上百万，那么树的高度会特别高，查找的次数会更多，磁盘io也会很大。所有尽量要树的高度越小，那么查找次数越少。

## 三、B-Tree

![](../pic/33.png)

高度跟二叉树相同的情况下存储的数更多。

## 四、B+Tree

mysql底层在B树的基础上优化为B+树

![](../pic/34.png)

B+树解决了平衡二叉树当数据越多，高度不可控的问题。

B树和B+树的区别

- B树的每个结点都存储了key和data，B+树的data存储在叶子节点上。节点不存储data，这样一个节点就可以存储更多的key。可以使得树更矮，所以IO操作次数更少。

- 树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。

## 五、B+Tree的查找

![](../pic/35.png)

将一个节点加载到内存就是一次io操作。版本高的mysql事先就会把非叶子结点加载到内存里面，效率更高，最终只需要一次磁盘查找就能找到元素。所以千万级别的表走索引也很快.

**上面说“B+树高度越小，效率更高”，那如果h=1是不是更好？**——不是的，高度为1的B+树相当于链表，而且全是叶子节点和data。1000w的表查找某个字段就把所有的节点加载到内存，不合适。一般来说会把冗余索引加载到内存，带有data的叶子节点不好加载到内存。

**当单表的数据量达到 1000W 或 100G 以后**，要求分库分表了。

## 六、Hash

![](../pic/51.png)

用来干嘛的？

![](../pic/52.png)

**为什么B+树能够支持范围查找？**

![](../pic/53.png)

## 七、索引使用介绍

**索引的创建**

![](../pic/59.png)

**哪些情况需要创建索引**

- 主键自动建立唯一索引
- 频繁作为查询条件的字段应该创建索引（银行系统的银行卡号，电信系统的手机号...）
- 查询中与其它表关联的字段，外键关系建立索引
- 频繁更新的字段不适合创建索引，因为每次更新不单单是更新了记录，还会更新索引，加重IO负担(不光更新数据，还会更新B+树)
- where条件里用不到的字段不创建索引
- 单键/组合索引的选择问题，who？（在高并发下倾向创建组合索引）
- 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度
- 查询中统计或者分组字段

**哪些情况不要创建索引**

- 表记录太少
- 经常增删改的表
  - Why：提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。

- 数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。

![](../pic/60.png)



