---
<!--cover: /assets/images/cover2.jpg-->
icon: pen-to-square
date: 2024-11-18
category:
  - Redis
tag:
  - redis使用场景
  - redis watch
star: true
ticky: true
---
# 6.1 一文了解Redis

## 一、Redis使用场景

- 缓存：将经常被访问的数据存储在Redis中，减少对数据库的访问压力
- 计数器：使用Redis的原子操作，实现高并发场景下的计数功能
- 分布式锁：使用Redis的原子操作和过期时间设置，实现分布式锁，确保在分布式系统中的数据一致性。
- 简单的发布订阅消息系统：实现消息的异步处理

## 二、Redis是单线程的

Redis是很快的，官⽅表示，Redis是基于**内存操作**，CPU不是Redis性能瓶颈，Redis的瓶颈是根据机器的**内存和⽹络带宽**，既然可以使⽤单线程来实现，就使⽤单线程了！所有就使⽤了单线程了！

**Redis单线程为什么还这么快？**——redis 是将所有的数据全部放在内存中的，所以说使⽤单线程去操作效率就是最⾼的，多线程（CPU上下⽂会切换：耗时的操作！！！），对于内存系统来说，如果没有上下⽂切换效率就是最⾼的！多次读写都是在⼀个CPU上的，在内存情况下，这个就是最佳的⽅案！

- 纯内存操作
- 单线程操作，避免了频繁的上下文切换  
- 采用了非阻塞I/O多路复用机制，参考[BIO、NIO文章](https://ranqingisfine.github.io/myBlog/%E4%B8%80%E3%80%81Java%E5%9F%BA%E7%A1%80/1.3%20Java%20IO%E6%A8%A1%E5%9E%8B/1.3.1%20BIO%E3%80%81NIO.html)

## 三、Redis Watch的理解

**Redis会不会产生ABA问题？**

在 Redis中使用 watch 命令可以决定事务是执行还是回滚。

一般而言，可以在 multi 命令之前使用 watch 命令监控某些键值对，然后使用 multi 命令开启事务，执行各类对数据结构进行操作的命令，这个时候这些命令就会进入队列。

当 Redis 使用 exec 命令执行事务的时候，它首先会去比对被 watch 命令所监控的键值对，

- 如果没有发生变化，那么它会执行事务队列中的命令，提交事务；
- 如果发生变化，那么它不会执行任何事务中的命令，而去事务回滚。

**使用watch成功提交的事务的案例：**

```shell
127.0.0.1:6379> FLUSHDB
OK
127.0.0.1:6379> SET key1 value1
OK
127.0.0.1:6379> WATCH key1
OK
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> SET key2 value2
QUEUED
127.0.0.1:6379> EXEC
1) OK
127.0.0.1:6379> 
```

**使用watch回滚的事务的案例**

```shell
127.0.0.1:6379> FLUSHDB
OK
127.0.0.1:6379> 
127.0.0.1:6379> SET key1 value1
OK
127.0.0.1:6379> WATCH key1
OK
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> set key2 value2
QUEUED

# 在这一步暂停下，打开第二个客户端去修改key1的值，然后再exec
127.0.0.1:6379> exec
(nil)
127.0.0.1:6379> 
```

客户端 1：执行事务，但是事务会先检查在 T2 时刻被监控的 key1 是否被其他命令修改过。因为客户揣 2 修改过，所以它会回滚事务，事实上如果客户端执行的是 set key1 value1 命令，它也会认为 key1 被修改过，然后返回( nil) ，所以是不会产生 ABA 问题的.

## 四、Redis高并发

redis高并发：主从架构，一主多从，一般来说，很多项目其实就足够了，单主用来写入数据，单机几万QPS，多从用来查询数据，多个从实例可以提供每秒10万的QPS。

