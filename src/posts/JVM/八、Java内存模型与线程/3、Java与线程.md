---
<!--cover: /assets/images/cover2.jpg-->
icon: pen-to-square
date: 2024-11-06
category:
  - JVM
  - Java内存模型与线程
tag:
  - 内核线程实现
  - 用户线程实现
  - 混合实现
  - 线程调度
  - 状态转换
star: true
ticky: true
---
# 8.3 Java与线程

进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。Thread所有关键方法都被声明为Native。

操作系统实现线程的三种方式：

- 使用内核线程实现（线程和内核线程1:1实现）
- 使用用户线程实现（进程和用户线程1:N实现）
- 使用用户线程➕轻量级进程混合实现（N:M实现）

## 一、内核线程实现

**Java线程是采用内核线程来实现的。**

内核线程是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。

程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口——轻量级进程（即线程）。每个线程都由一个内核线程支持，这种线程和内核线程之间1:1的关系成为一对一的线程模型。

**优点**： 每个线程是一个独立的调度单元，即使其中某一个阻塞了，也不会影响整个进程继续工作。

**缺点**：

- 由于是基于内核线程实现的，所以各种线程操作如创建等，都需要进行系统调用。而系统调用的代价高，需要在用户态和内核态中来回切换，这两种状态切换开销的主要源自响应中断、保护和恢复执行现场的成本。
- 每个线程都需要有一个内核线程的支持，因此线程会消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持线程的数量是有限的。

## 二、用户线程实现

用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知用户线程的存在以及如何实现的。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。

如果程序实现得当，这种线程不需要切换到内核态，因此操作快、消耗低，能支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。

**缺点：**没有系统内核的支援，所有的线程操作都需要由用户程序自己去处理。

以高并发为卖点的编程语言如：Golang、Erlang等，普遍使用了用户线程实现。

## 三、混合实现

即存在用户线程也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换等操作依然廉价，并且支持大规模的并发。而操作系统的轻量级进程作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能以及处理器映射，并且用户线程的系统调度要通过轻量级进程来完成，大大降低了整个进程被完全阻塞的风险

## 四、Java线程调度

线程调度指处理器为线程分配处理器使用权的过程，调度主要有两种方式：**协同式和抢占式**线程调度。

> 协同式线程调度

协同式线程调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完成后，要主动通知系统切换到另外一个线程上去。

**优点**：因为线程干完后才切换，所以一般没有线程同步的问题。例如Lua语言中的“协同例程”就是这类实现。

**缺点**：线程执行时间不可控，如果一个线程编码有问题，一直不告知系统切换，那么程序会一直阻塞在那里。

> 抢占式调度

如果使用抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程切换不由线程本身来决定。例如Java中Thread.yield()方法可以主动让出执行时间，但是如果想要主动获取执行时间，线程本身是没有什么方法的。

Java使用的线程调度方式就是抢占式调度。

虽然Java线程调度是系统自动完成的，但是我们还是可以建议操作系统给某些线程多分配一点执行时间。Java语言设置了10个级别的线程优先级。不过线程优先级并不是一项稳定的手段，线程调度还是由操作系统说了算。

## 五、状态转换

- 新建
- 运行
- 无限期等待
- 有限等待
- 阻塞
- 结束











