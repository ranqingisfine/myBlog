---
<!--cover: /assets/images/cover2.jpg-->
icon: pen-to-square
date: 2025-02-26
category:
  - LeetCode 
tag:
  - 贪心
star: true 
ticky: true

---

# 8.1.14 加油站

leetCode.134

**题目**：在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。

你有一辆油箱容量无限的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组 `gas` 和 `cost` ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 **保证** 它是 **唯一** 的。

**分析**：

- 总油量判断：如果所有加油站的总汽油量 `sum(gas)` < 总消耗 `sum(cost)`，则一定无解，直接返回 `-1`。

贪心策略（核心）：

- 遍历每个加油站，维护两个变量：
  - `currentGas`：当前累计的剩余汽油（从候选起点出发到当前加油站的剩余油量）。
  - `start`：候选起点索引（初始为 0）。
- 遍历到第 i个加油站时，计算 ``currentGas += gas[i] - cost[i]``
  - 如果 `currentGas < 0`，说明从 `start` 到 `i` 之间的所有点都不能作为起点（因为从这些点出发到 `i` 都会油量不足），因此将 `start` 更新为 `i+1`，并重置 `currentGas` 为 0。
- 遍历结束后，若总油量足够（sum (gas) >= sum (cost)），则 `start` 就是唯一解（题目保证解唯一）。

注意：为什么说`currentGas<0`则`start`到`i`之间的所有点都不能作为起点？

```
若A=k ～ 最后一站 的总剩余（≥0）、B = 0 ～ k‑1 的总剩余（可能负）、total = A + B ≥ 0（总油够）
那么，由于A+B>0  --->  B>-A
理解：0～k‑1 这段路会携带油A，亏的油可以用A覆盖！
大白话：0～k‑1 这段路本身可能是亏的，但你不是从零开始走，你是带着前面赚的油进去走，而总油量刚好保证：你赚的油 ≥ 这段路的最大亏损
```



**代码**：

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int n = gas.length;
        int totalGas = 0;    // 总汽油量
        int totalCost = 0;   // 总消耗量
        int currentGas = 0;  // 当前累计剩余汽油
        int start = 0;       // 候选起点
        //遍历加油站
        for (int i = 0; i < n; i++) {
            totalGas += gas[i];
            totalCost += cost[i];
            // 计算当前加油站的剩余油量（加油 - 开到下一站的消耗）
            currentGas += gas[i] - cost[i];
            
            // 如果当前累计油量不足，说明start到i都不能作为起点
            if (currentGas < 0) {
                start = i + 1;  // 候选起点更新为i+1
                currentGas = 0; // 重置当前累计油量
            }
        }
        // 总油量 >= 总消耗则有解，否则无解
        return totalGas >= totalCost ? start : -1;
    }
}
```









