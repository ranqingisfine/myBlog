---
<!--cover: /assets/images/cover2.jpg-->
icon: pen-to-square
date: 2024-11-27
category:
  - 并发编程
  - Java中的锁
tag:
  - 读写锁
star: true
ticky: true
---
# 4.5.4 读写锁

## 一、概念

先代入两个问题：1、只在写操作加互斥锁不行吗，为什么非要读写锁。2、什么场景会用到读写锁。

读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其它写线程均被阻塞。特点是**读读不互斥、读写互斥、写写互斥**。

读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升，它的优点有：

- 提高了程序执行性能：多个读锁可以同时执行，相比于普通锁在任何情况下都要排队执行来说，读写锁提高了程序的执行性能
- 避免读到临时数据：读锁和写锁是互斥排队执行的，这样可以保证了读取操作不会读到写了一半的临时数据。

**特性**：

- 非公平锁（默认），也可选择公平锁
- 重进入
- 锁降级：获取写锁-->获取读锁-->释放写锁，即写锁能够降级成读锁

**读写锁的使用**

在 Java 语言中，读写锁是使用 ReentrantReadWriteLock 类来实现的，其中：

- ReentrantReadWriteLock.ReadLock 表示读锁，它提供了 lock 方法进行加锁、unlock 方法进行解锁。
- ReentrantReadWriteLock.WriteLock 表示写锁，它提供了 lock 方法进行加锁、unlock 方法进行解锁。

在分布式场景中，读写锁建议采用Redisson来实现，具体请参考下面的Redisson文章

## 二、场景

读写锁有以下**特点**：

- 允许多个线程在没有写入时同时读取，可以提高读取效率
- 当存在写入情况时，只允许一个线程写入，其他线程进入排队等待
- 适合读多写少的场景

**读写锁适合多读少写的业务场景**，对于同一个数据，有大量线程读取，但仅有少数线程修改，使用`ReadWriteLock`可以显著的提升程序并发执行效率。例如，一个论坛的帖子，浏览可以看做读取操作，是非常频繁的，而回复可以看做写入操作，它是不频繁的.

比如在业务中碰到下面的这个情况：

```
xx平台评论功能使用了读写锁实现，锁对象是文章编号。写操作的时候需要加锁，因为写业务需要往数据库表里面新增一条评论，然后总览里该文章和总文章的评论数+1，如果不加锁，评论数统计会不准确。为什么要用读写锁，1 因为读读不需要加锁，提高性能；2 读写和写写加锁，防止出现脏读和幻读比如两次读到情况不一致的情况，比如读区发生在写操作的中间，会出现读取到了评论，但是评论数未加1。
```

看到这里，就不难回答前面提的两个问题了。







